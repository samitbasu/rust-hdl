"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[697],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),m=i,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||a;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var u=2;u<a;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9869:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var r=n(7462),i=(n(7294),n(3905));const a={},o="Traits",l={unversionedId:"guide/rusthdl/traits",id:"guide/rusthdl/traits",title:"Traits",description:"There is only one trait that you typically need to implement to get things to work in RustHDL",source:"@site/docs/guide/rusthdl/traits.md",sourceDirName:"guide/rusthdl",slug:"/guide/rusthdl/traits",permalink:"/guide/rusthdl/traits",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/rusthdl/traits.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Synthesizable Subset of Rust",permalink:"/guide/rusthdl/synthesizable"},next:{title:"Generating Verilog",permalink:"/guide/rusthdl/verilog"}},s={},u=[],p={toc:u},c="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"traits"},"Traits"),(0,i.kt)("p",null,"There is only one trait that you typically need to implement to get things to work in RustHDL\nwith the simulation and synthesis frameworks.  That is the ",(0,i.kt)("a",{parentName:"p",href:"core::logic::Logic"},"Logic")," trait.\nAlthough you will rarely (if ever) need to implement the methods themselves, here is the\nfull definition of the trait:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"\npub trait Logic {\n    fn update(&mut self);\n    fn connect(&mut self) {}\n    fn hdl(&self) -> Verilog {\n        Verilog::Empty\n    }\n    fn timing(&self) -> Vec<TimingInfo> {\n        vec![]\n    }\n}\n")),(0,i.kt)("p",null,"The methods are quite simple:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"update")," - this updates the state of the logical block based on the inputs and internal state.\nIn general, this is where the action of the logical block takes place."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connect")," - this is where we claim whatever signals we drive, by calling ",(0,i.kt)("inlineCode",{parentName:"li"},"connect")," on them."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hdl")," - this method returns the Verilog description for our logical block in the form of\nan ",(0,i.kt)("a",{parentName:"li",href:"core::ast::Verilog"},"Verilog")," enum."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timing")," - this is where specific timing exceptions or requirements are expressed for the\nlogical block.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"In almost all cases, you will use the ",(0,i.kt)("inlineCode",{parentName:"p"},"#[derive(LogicBlock)]")," macro to derive all of the traits from your own ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," method, written in Rust.  ")),(0,i.kt)("p",null,"If we revisit the ",(0,i.kt)("inlineCode",{parentName:"p"},"Blinky")," example, note that\nwe only provided the ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," method, with an attribute of ",(0,i.kt)("inlineCode",{parentName:"p"},"#[hdl_gen]"),", which in turn\ngenerated the remaining trait implementations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"}," #[derive(LogicBlock)]\n struct Blinky {\n    pub clock: Signal<In, Clock>,\n    pulser: Pulser,\n    pub led: Signal<Out, Bit>,\n }\n\n impl Logic for Blinky {\n    #[hdl_gen]\n    fn update(&mut self) {\n       self.pulser.clock.next = self.clock.val();\n       self.pulser.enable.next = true.into();\n       self.led.next = self.pulser.pulse.val();\n    }\n}  \n")),(0,i.kt)("p",null," There are a couple of other traits that RustHDL uses that you should be aware of."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Synth")," - this trait is provided on types that can be represented in hardware, i.e. as\na set of bits.  You will probably not need to implement this trait yourself, but if you\nneed some special type representation ",(0,i.kt)("inlineCode",{parentName:"li"},"Foo"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"impl Synth for Foo"),", then RustHDL will\nbe able to generate Verilog code for it."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Block")," - this trait is needed on any ",(0,i.kt)("inlineCode",{parentName:"li"},"struct")," that is a composition of circuit elements\n(pretty much every struct used to model a circuit).  This should be auto-derived."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Logic")," - Sometimes, you will need to override the default implementations of the ",(0,i.kt)("inlineCode",{parentName:"li"},"Logic"),"\ntrait.  In those cases, (when you are providing a custom simulation model, or wrapping a\nblack box Verilog routine), you will need to ",(0,i.kt)("inlineCode",{parentName:"li"},"impl")," the other methods.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},'The main need for implementing a trait is when you want to represent some logic block\nthat has "magic" internals.  Like a RAM block or some special SerDes circuitry.')))}d.isMDXComponent=!0}}]);