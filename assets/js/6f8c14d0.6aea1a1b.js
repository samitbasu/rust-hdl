"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[38],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>d});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),g=u(r),m=o,d=g["".concat(s,".").concat(m)]||g[m]||p[m]||i;return r?n.createElement(d,a(a({ref:t},c),{},{components:r})):n.createElement(d,a({ref:t},c))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[g]="string"==typeof e?e:o,a[1]=l;for(var u=2;u<i;u++)a[u]=r[u];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},2005:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var n=r(7462),o=(r(7294),r(3905));const i={},a="Verilog",l={unversionedId:"guide/programming/verilog",id:"guide/programming/verilog",title:"Verilog",description:"Verilog was originally a language for simulating the behavior of digital circuits",source:"@site/docs/guide/programming/verilog.md",sourceDirName:"guide/programming",slug:"/guide/programming/verilog",permalink:"/guide/programming/verilog",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/programming/verilog.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Python Based Approaches",permalink:"/guide/programming/migen"},next:{title:"Using RustHDL",permalink:"/guide/rusthdl/"}},s={},u=[],c={toc:u},g="wrapper";function p(e){let{components:t,...r}=e;return(0,o.kt)(g,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"verilog"},"Verilog"),(0,o.kt)("p",null,'Verilog was originally a language for simulating the behavior of digital circuits\nthat over time, became repurposed for FPGA programming.  FPGA programming is generally\n"structural", and not "behavioral".  Going back to the kitchen analogy (again?? Is this\nguy permanently hungry?), an FPGA program is like a floor plan for a factory.  It tells\nyou what sections are set up to do what function, and tells you how they are connected\nto each other.  It does not (necessarily) tell you how that system behaves.  This is\nexactly unlike CPU programming, which is a series of directed instructions, like a recipe.\nIn most software languages, you provide a series of instructions, or maybe you describe\nthe desired outcome.  In both cases, the CPU ends up with a stream of instructions telling\nit to chop this, dice that, and then add the rice.  '),(0,o.kt)("p",null,"Verilog is the lingua franca of the FPGA world.  And it is still the main way FPGAs are\nprogrammed.  All of the newer technologies/languages ultimately generate Verilog or something\nequivalent to it.  The toolchains, after all, expect Verilog as input."),(0,o.kt)("p",null,"So are we done?  Maybe!  For many FPGA developers (particularly those with hardware backgrounds),\nVerilog or VHDL are the end of the story.  Much the same way for many CPU programmers, assembly\nlanguage or machine code are sufficient.  End of story.  For the rest of us, the goal is\nto make developing FPGA programs slightly less traumatizing.  Compiler technology has come\na long, long way in the past several decades.  The Rust compiler (see!  I hadn't forgot\nthe purpose of this book) is incredibly sophisticated, and it goes through all kinds of hoops\nto make sure you don't do silly things.  "),(0,o.kt)("p",null,"Verilog lacks those same safeties.  It gives you, as the developer, ultimate power and\nflexibility, with no guide-rails.  There are carefully constructed lists of rules regarding\nhow to use Verilog in ways that give up much of its flexibility in favor of readability."))}p.isMDXComponent=!0}}]);