"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[462],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=a.createContext({}),u=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(r.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,r=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=u(n),c=i,f=d["".concat(r,".").concat(c)]||d[c]||m[c]||l;return n?a.createElement(f,s(s({ref:t},p),{},{components:n})):a.createElement(f,s({ref:t},p))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,s=new Array(l);s[0]=c;var o={};for(var r in t)hasOwnProperty.call(t,r)&&(o[r]=t[r]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var u=2;u<l;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},20:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const l={},s="Synthesizable Subset of Rust",o={unversionedId:"guide/rusthdl/synthesizable",id:"guide/rusthdl/synthesizable",title:"Synthesizable Subset of Rust",description:"RustHDL uses procedural macros to define a subset of the Rust language that can be used to",source:"@site/docs/guide/rusthdl/synthesizable.md",sourceDirName:"guide/rusthdl",slug:"/guide/rusthdl/synthesizable",permalink:"/guide/rusthdl/synthesizable",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/rusthdl/synthesizable.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Struct valued signals",permalink:"/guide/rusthdl/struct_valued"},next:{title:"Traits",permalink:"/guide/rusthdl/traits"}},r={},u=[{value:"Valid Rust",id:"valid-rust",level:2},{value:"HDL Kernel Signature",id:"hdl-kernel-signature",level:2},{value:"Assignments",id:"assignments",level:2},{value:"Unary operators",id:"unary-operators",level:2},{value:"Conditionals",id:"conditionals",level:2},{value:"Literals and Function Calls",id:"literals-and-function-calls",level:2},{value:"Matches",id:"matches",level:2},{value:"Macros",id:"macros",level:2},{value:"Loops",id:"loops",level:2},{value:"Enums",id:"enums",level:2}],p={toc:u},d="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"synthesizable-subset-of-rust"},"Synthesizable Subset of Rust"),(0,i.kt)("p",null,"RustHDL uses procedural macros to define a subset of the Rust language that can be used to\ndescribe actual hardware.  That subset is known as the synthesizable subset of Rust.  It is\nquite limited because the end result is translated into Verilog and ultimately into hardware\nconfiguration for the FPGA."),(0,i.kt)("h2",{id:"valid-rust"},"Valid Rust"),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"The HDL kernel must be valid Rust!  If you remove the ",(0,i.kt)("inlineCode",{parentName:"p"},"#[hdl_gen]")," attribute, the code\nmust still be accepted by ",(0,i.kt)("inlineCode",{parentName:"p"},"rustc"),"!  That means you must satisfy the type constraints, the\nprivate nature of the struct fields, etc.  This is one of the major benefits of RustHDL.  It\ntakes code that is already been checked by ",(0,i.kt)("inlineCode",{parentName:"p"},"rustc")," and then converts it into HDL.")),(0,i.kt)("p",null,"So this will ",(0,i.kt)("em",{parentName:"p"},"clearly")," fail to compile."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'struct Foo {\n bar: Signal<Out, Bits<4>>\n}\n\nimpl Logic for Foo {\n   #[hdl_gen]\n   fn update(&mut self) {\n      self.bar.next = "Oy!"; // Type issue here...\n   }\n}\n')),(0,i.kt)("h2",{id:"hdl-kernel-signature"},"HDL Kernel Signature"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#[hdl_gen]")," attribute can only be applied to a function (aka HDL Kernel) that\ntakes ",(0,i.kt)("inlineCode",{parentName:"p"},"&mut self")," as an argument. ")),(0,i.kt)("p",null,"In almost all cases, you will write something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"struct Foo {}\n\nimpl Logic for Foo {\n  #[hdl_gen]\n  fn update(&mut self) {\n     // Put your synthesizable subset of Rust here...\n  }\n}\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The body of the ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," function must be a single block, consisting of statements.\nLocal definitions and items are not allowed in HDL kernels.  The following, for example, will\nfail.  ")),(0,i.kt)("p",null,"This is an example of valid Rust that is not allowed in an HDL kernel."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"struct Foo {}\n\nimpl Logic for Foo {\n   #[hdl_gen]\n   fn update (&mut self) {\n     // Fails because local items are not allowed in HDL kernels.\n     let x = 32;\n   }\n}\n")),(0,i.kt)("h2",{id:"assignments"},"Assignments"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Assignments are allowed as long as you follow the rules about signals.  Types are\nstill enforced by Rust.")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Indexed assignments are currently not supported")),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Signal assignments must be to either ",(0,i.kt)("inlineCode",{parentName:"p"},".next")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".next.field")," if the signal is struct based.")),(0,i.kt)("p",null,"So valid assignments will be of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"self.<signal>.next = <expr>"),", or for structure-valued\nsignals."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Expressions support accessing fields of a signal"),(0,i.kt)("li",{parentName:"ul"},"Binary operations supported are ",(0,i.kt)("inlineCode",{parentName:"li"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"&&"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"||"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"^"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"&"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"|"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"<<"),", ",(0,i.kt)("inlineCode",{parentName:"li"},">>"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"=="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"<"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"<="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"!="),", ",(0,i.kt)("inlineCode",{parentName:"li"},">"),", ",(0,i.kt)("inlineCode",{parentName:"li"},">="),"\nIn general, binary operations require that both arguments are of the same type (e.g. bitwidth) or one of the\narguments will be a literal.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n\nstruct Foo {\n   pub sig1: Signal<In, Bits<4>>,\n   pub sig2: Signal<In, Bits<4>>,\n   pub sig3: Signal<Out, Bits<4>>,\n}\n\nimpl Logic for Foo {\n   #[hdl_gen]\n   fn update(&mut self) {\n      self.sig3.next = self.sig1.val() + 4; // Example of binop with a literal\n      self.sig3.next = self.sig1.val() ^ self.sig2.val(); // Example of a binop with two bitvecs\n   }\n}\n")),(0,i.kt)("h2",{id:"unary-operators"},"Unary operators"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Unary operations supported are ",(0,i.kt)("inlineCode",{parentName:"li"},"-")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"!"),"\nThe ",(0,i.kt)("inlineCode",{parentName:"li"},"-")," operator is only supported for ",(0,i.kt)("inlineCode",{parentName:"li"},"Signed")," types.  Otherwise, it makes no sense.  If\nyou want to compute the 2's complement of an unsigned value, you need to do so explicitly.\nThe ",(0,i.kt)("inlineCode",{parentName:"li"},"!")," operator will flip all of the bits in the bitvector.")),(0,i.kt)("h2",{id:"conditionals"},"Conditionals"),(0,i.kt)("p",null,"Conditionals (",(0,i.kt)("inlineCode",{parentName:"p"},"if"),") are supported."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n\nstruct Foo {\n    pub sig1: Signal<In, Bit>,\n    pub sig2: Signal<Out, Bits<2>>,\n    pub sig3: Signal<In, Bits<2>>,\n    pub sig4: Signal<Out, Bits<2>>,\n}\n\nimpl Logic for Foo {\n    #[hdl_gen]\n    fn update(&mut self) {\n        self.sig2.next = 0.into(); // Latch prevention!\n        // Straight `if`s are supported, but beware of latches!\n        // This `if` statement would generate a latch if not for\n        // the unconditional assign to `sig2`\n        if self.sig1.val() {\n           self.sig2.next = 1.into();\n        }\n        // You can use `else` clauses also\n        if self.sig1.val() {\n           self.sig2.next = 1.into();\n        } else {\n           self.sig2.next = 2.into();\n        }\n        // Nesting and chaining are also fine\n        if self.sig3.val() == 0 {\n           self.sig4.next = 3.into();\n        } else if self.sig3.val() == 1 {\n           self.sig4.next = 2.into();\n        } else {\n           self.sig4.next = 0.into();   // <- Fall through else prevents latch\n        }\n    }\n}\n")),(0,i.kt)("h2",{id:"literals-and-function-calls"},"Literals and Function Calls"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Literals (provided they implement the ",(0,i.kt)("inlineCode",{parentName:"li"},"Synth")," trait) are supported.  In most cases, you\ncan used un-suffixed literals (like ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"0xDEAD"),") as add ",(0,i.kt)("inlineCode",{parentName:"li"},".into()"),"."),(0,i.kt)("li",{parentName:"ul"},"Function calls - RustHDL kernels support a very limited number of function calls, all of\nwhich are ignored in HDL at the moment (they are provided to make ",(0,i.kt)("inlineCode",{parentName:"li"},"rustc")," happy)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bit_cast")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"signed_bit_cast")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"unsigned_cast")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bits")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Bits")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Type::join")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Type::link")," used to link and join logical interfaces..."))),(0,i.kt)("li",{parentName:"ul"},"Method calls - Kernels support the following limited set of method calls",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get_bits")," - extract a (fixed width) set of bits from a bit vector"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get_bit")," - extract a single bit from a bit vector"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replace_bit")," - replace a single bit in a bit vector"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"all")," - true if all the bits in the bit vector are true"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"any")," - true if any of the bits in the bit vector are true"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"xor")," - true if the number of ones in the bit vector is odd"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"val"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"into"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"index"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"to_bits")," - ignored in HDL kernels")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n\nstruct Foo {\n    pub sig1: Signal<In, Bits<8>>,\n    pub sig_index: Signal<In, Bits<3>>,\n    pub sig2: Signal<Out, Bit>,\n    pub sig3: Signal<Out, Bits<3>>,\n    pub sig4: Signal<Out, Bit>,\n}\n\nimpl Logic for Foo {\n    #[hdl_gen]\n    fn update(&mut self) {\n        self.sig2.next = self.sig1.val().get_bit(self.sig_index.val().index()); // <- Selects specified bit out of sig1\n        self.sig3.next = self.sig1.val().get_bits::<3>(self.sig_index.val().index()); // Selects 3 bits starting at index `sig_index`\n        // Notice that here we have an output on both the left and right side of the assignment\n        // That is fine as long we we write to `.next` before we read from `.val`.\n        self.sig4.next = self.sig3.val().all(); // True if sig3 is all true\n    }\n}\n")),(0,i.kt)("h2",{id:"matches"},"Matches"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Matches - Kernels support matching with literals or identifiers\nMatches are used for state machines and implementing ROMs.",(0,i.kt)("br",{parentName:"li"}),"For now, ",(0,i.kt)("inlineCode",{parentName:"li"},"match")," is a statement, not an expression!  Maybe that will be fixed in a future\nversion of RustHDL, but for now, the value of the ",(0,i.kt)("inlineCode",{parentName:"li"},"match")," is ignored.\nHere is an example of a ",(0,i.kt)("inlineCode",{parentName:"li"},"match")," for a state machine:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n# use rust_hdl::widgets::prelude::*;\n\n#[derive(Copy, Clone, PartialEq, Debug, LogicState)]\nenum State {\n    Idle,\n    Running,\n    Paused,\n}\n\n\nstruct Foo {\n    pub start: Signal<In, Bit>,\n    pub pause: Signal<In, Bit>,\n    pub stop: Signal<In, Bit>,\n    pub clock: Signal<In, Clock>,\n    state: DFF<State>,\n}\n\nimpl Logic for Foo {\n    #[hdl_gen]\n    fn update(&mut self) {\n       dff_setup!(self, clock, state); // <- setup the DFF\n       match self.state.q.val() {\n           State::Idle =>\n                  if self.start.val() {\n                     self.state.d.next = State::Running;\n                  }\n           State::Running =>\n                  if self.pause.val() {\n                     self.state.d.next = State::Paused;\n                  }\n           State::Paused =>\n                  if !self.pause.val() {\n                     self.state.d.next = State::Running;\n                  }\n       }\n       if self.stop.val() {\n           self.state.d.next = State::Idle;\n       }\n    }\n}\n")),(0,i.kt)("h2",{id:"macros"},"Macros"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Macros - some macros are supported in kernels",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"println")," - this is converted into a comment in the generated HDL"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"comment")," - also a comment"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"assert")," - converted to a comment"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dff_setup")," - setup a DFF - this macro is converted into the appropriate HDL"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"clock")," - clock a set of components - this macro is also converted into the appropriate HDL")))),(0,i.kt)("h2",{id:"loops"},"Loops"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Loops - ",(0,i.kt)("inlineCode",{parentName:"li"},"for")," loops are supported for code generation")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"In software parlance, all ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loops are unrolled at compile time, so they must be of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"for <ident> in <const>..<const>"),".")),(0,i.kt)("p",null,"A simple example to consider is a parameterizable mux."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n\n// Mux from N separate signals, using A address bits\n// For fun, it's also generic over the width of the\n// signals being muxed.  So there are 3 generics here:\n//    - D - the type of those signals\n//    - N - the number of signals being muxed\n//    - A - the number of address bits (check that 2^A >= N)\nstruct Mux<D: Synth, const N: usize, const A: usize> {\n   pub input_lines: [Signal<In, D>; N],\n   pub select: Signal<In, Bits<A>>,\n   pub outsig: Signal<Out, D>,\n   fallback: Constant<D>,\n}\n\n// The impl for this requires a for loop\nimpl<D: Synth, const N: usize, const A: usize> Logic for Mux<D, N, A> {\n  #[hdl_gen]\n  fn update(&mut self) {\n       self.outsig.next = self.fallback.val();\n       for i in 0..N {\n          if self.select.val().index() == i {\n             self.outsig.next = self.input_lines[i].val();\n          }\n       }\n   }\n}\n")),(0,i.kt)("p",null,"RustHDL is still pretty restrictive about arrays and loops.  You can still do great stuff though."),(0,i.kt)("p",null,"Since an example is instructive, here is the HDL kernel for a nontrivial circuit (the ",(0,i.kt)("inlineCode",{parentName:"p"},"SPIMaster"),"),\nannotated to demonstrate the various valid bits of syntax.  It's been heavily redacted to make\nit easier to read."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// Note - you can use const generics in HDL definitions and kernels!\n#[derive(LogicBlock)]\nstruct SPIMaster<const N: usize> {\n    // The `pub` members are the ones you can access from other circuits.\n    // These form the official interface of the circuit\n    pub clock: Signal<In, Clock>,\n    pub bits_outbound: Signal<In, Bits<16>>,\n    pub data_outbound: Signal<In, Bits<N>>,\n    // snip...\n    // These are private, so they can only be accessed by internal code\n    register_out: DFF<Bits<N>>,\n    register_in: DFF<Bits<N>>,\n    state: DFF<SPIState>,\n    strobe: Strobe<32>,\n    pointer: DFF<Bits<16>>,\n     // snip...\n    // Computed constants need to be stored in a special Constant field member\n    cs_off: Constant<Bit>,\n    mosi_off: Constant<Bit>,\n}\n\nimpl<const N: usize> Logic for SPIMaster<N> {\n    #[hdl_gen]\n    fn update(&mut self) {\n        // Setup the internals - for Latch avoidance, each digital flip flop\n        // requires setup - it needs to be clocked, and it needs to connect\n        // the output and input together, so that the input is driven.\n        // This macro simply declutters the code a bit and makes it easier to read.\n        dff_setup!(\n            self,\n            clock,\n            //   | equivalent to `self.register_out.clock.next = self.clock.val();`\n            // v--               `self.register_out.d.next = self.register_out.q.val();`\n            register_out,\n            register_in,\n            state,\n            pointer,\n        );\n        // This macro is shorthand for `self.strobe.next = self.clock.val();`\n        clock!(self, clock, strobe);\n        // These are just standard assignments... Nothing too special.\n        // Note that `.next` is on the LHS, and `.val()` on the right...\n        self.strobe.enable.next = true;\n        self.wires.mclk.next = self.clock_state.q.val();\n        self.wires.msel.next = self.msel_flop.q.val();\n        self.data_inbound.next = self.register_in.q.val();\n        self.pointerm1.next = self.pointer.q.val() - 1;\n        // The `match` is used to model state machines\n        match self.state.q.val() {\n            SPIState::Idle => {\n                self.busy.next = false;\n                self.clock_state.d.next = self.cpol.val();\n                if self.start_send.val() {\n                    // Capture the outgoing data in our register\n                    self.register_out.d.next = self.data_outbound.val();\n                    self.state.d.next = SPIState::Dwell; // Transition to the DWELL state\n                    self.pointer.d.next = self.bits_outbound.val(); // set bit pointer to number of bit to send (1 based)\n                    self.register_in.d.next = 0.into(); // Clear out the input store register\n                    self.msel_flop.d.next = !self.cs_off.val(); // Activate the chip select\n                    self.continued_save.d.next = self.continued_transaction.val();\n                } else {\n                    if !self.continued_save.q.val() {\n                        self.msel_flop.d.next = self.cs_off.val(); // Set the chip select signal to be "off"\n                    }\n                }\n                self.mosi_flop.d.next = self.mosi_off.val(); // Set the mosi signal to be "off"\n            }\n            SPIState::Dwell => {\n                if self.strobe.strobe.val() {\n                    // Dwell timeout has reached zero\n                    self.state.d.next = SPIState::LoadBit; // Transition to the loadbit state\n                }\n            }\n            SPIState::LoadBit => {\n                // Note in this statement that to use the pointer register as a bit index\n                // into the `register_out` DFF, we need to convert it with `index()`.\n                if self.pointer.q.val().any() {\n                    // We have data to send\n                    self.mosi_flop.d.next = self\n                        .register_out\n                        .q\n                        .val()\n                        .get_bit(self.pointerm1.val().index()); // Fetch the corresponding bit out of the register\n                    self.state.d.next = SPIState::MActive; // Move to the hold mclock low state\n                    self.clock_state.d.next = self.cpol.val() ^ self.cpha.val();\n                } else {\n                    self.mosi_flop.d.next = self.mosi_off.val(); // Set the mosi signal to be "off"\n                    self.clock_state.d.next = self.cpol.val();\n                    self.state.d.next = SPIState::Finish; // No data, go back to idle\n                }\n            }\n            SPIState::MActive => {\n                if self.strobe.strobe.val() {\n                    self.state.d.next = SPIState::SampleMISO;\n                }\n            }\n       }\n    }\n}\n')),(0,i.kt)("h2",{id:"enums"},"Enums"),(0,i.kt)("p",null,"In keeping with Rust's strongly typed model, you can use enums (not sum types) in your HDL,\nprovided you derive the ",(0,i.kt)("inlineCode",{parentName:"p"},"LogicState")," trait for them.  This makes your code much easier to\nread and debug, and ",(0,i.kt)("inlineCode",{parentName:"p"},"rustc")," will make sure you don't do anything illegal with your\nenums."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n\n#[derive(Copy, Clone, PartialEq, Debug, LogicState)]\nenum State {\n    Idle,\n    Running,\n    Paused,\n}\n")),(0,i.kt)("p",null,"Using enums for storing things like state has several advantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"RustHDL will automatically calculate the minimum number of bits needed to store the\nenum in e.g., a register.")),(0,i.kt)("p",null,"For example, we can create a Digital Flip Flop (register) of value ",(0,i.kt)("inlineCode",{parentName:"p"},"State")," from the next\nexample, and RustHDL will convert this into a 2 bit binary register.  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n# use rust_hdl::widgets::prelude::*;\n\n#[derive(Copy, Clone, PartialEq, Debug, LogicState)]\nenum State {\n    Idle,\n    Sending,\n    Receiving,\n    Done,\n}\n\nstruct Foo {\n    dff: DFF<State>,  // <-- This is a 2 bit DFF\n}\n")),(0,i.kt)("p",null,"Now imagine we add another state in the future to our state machine - say ",(0,i.kt)("inlineCode",{parentName:"p"},"Pending"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n# use rust_hdl::widgets::prelude::*;\n\n#[derive(Copy, Clone, PartialEq, Debug, LogicState)]\nenum State {\n    Idle,\n    Sending,\n    Receiving,\n    Pending,\n    Done,\n}\n\nstruct Foo {\n    dff: DFF<State>,  // <-- This is now a 3 bit DFF!\n}\n")),(0,i.kt)("p",null,"RustHDL will ",(0,i.kt)("em",{parentName:"p"},"automatically")," choose a 3-bit representation.  "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"RustHDL will ensure that assignments to ",(0,i.kt)("inlineCode",{parentName:"li"},"enum"),"-valued signals are valid at all times")),(0,i.kt)("p",null,"The strong type guarantees ensure you cannot assign arbitrary values to ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," valued\nsignals, and the namespaces ensure that there is no ambiguity in assignment.  This example\nwon't compile, since ",(0,i.kt)("inlineCode",{parentName:"p"},"On")," without the name of the ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," means nothing, and ",(0,i.kt)("inlineCode",{parentName:"p"},"State1")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"State2")," are separate types.  They cannot be assigned to one another."),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"This example won't compile.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n\n#[derive(Copy, Clone, PartialEq, Debug, LogicState)]\nenum State1 {\n     On,\n     Off,\n}\n\n#[derive(Copy, Clone, PartialEq, Debug, LogicState)]\nenum State2 {\n     Off,\n     On,\n}\n\nstruct Foo {\n    pub sig_in: Signal<In, State1>,\n    pub sig_out: Signal<Out, State2>,\n}\n\nimpl Logic for Foo {\n    #[hdl_gen]\n    fn update(&mut self) {\n        self.sig_out.next = On; // << This won't work either.\n        self.sig_out.next = self.sig_in.val(); // << Won't compile\n    }\n}\n")),(0,i.kt)("p",null,"If for some reason, you needed to translate between enums, use a ",(0,i.kt)("inlineCode",{parentName:"p"},"match"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"impl Logic for Foo {\n   #[hdl_gen]\n   fn update(&mut self) {\n      match self.sig_in.val() {\n          State1::On => self.sig_out.next = State2::On,\n          State1::Off => self.sig_out.next = State2::Off,\n      }\n   }\n}\n")))}m.isMDXComponent=!0}}]);