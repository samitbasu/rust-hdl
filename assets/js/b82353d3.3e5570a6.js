"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[439],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?r.createElement(h,a(a({ref:t},p),{},{components:n})):r.createElement(h,a({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:o,a[1]=l;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7699:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const i={},a="Wrapping IP Cores",l={unversionedId:"guide/rusthdl/wrapping",id:"guide/rusthdl/wrapping",title:"Wrapping IP Cores",description:"Occasionally in RustHDL, you will need to wrap an external IP core or logic primitive supported",source:"@site/docs/guide/rusthdl/wrapping.md",sourceDirName:"guide/rusthdl",slug:"/guide/rusthdl/wrapping",permalink:"/guide/rusthdl/wrapping",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/rusthdl/wrapping.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Generating Verilog",permalink:"/guide/rusthdl/verilog"},next:{title:"Roadmap",permalink:"/roadmap"}},s={},c=[],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"wrapping-ip-cores"},"Wrapping IP Cores"),(0,o.kt)("p",null,"Occasionally in RustHDL, you will need to wrap an external IP core or logic primitive supported\nby your hardware, but that is not supported directly in RustHDL.  There best method for wrapping\nVerilog code is to use the ",(0,o.kt)("a",{parentName:"p",href:"core::ast::Wrapper"},"Wrapper")," struct and provide your own implementation\nof the ",(0,o.kt)("inlineCode",{parentName:"p"},"hdl")," method for your logic."),(0,o.kt)("p",null,"Here is a minimal example of a clock buffer primitive (that takes a differential clock input\nand provides a single ended clock output).  The Verilog module declaration for the clock buffer is\nsimply:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"module IBUFDS(I, B, O);\n   input I;\n   input B;\n   output O;\nendmodule\n")),(0,o.kt)("p",null,"Since the implementation of this device is built into the FPGA (it is a hardware primitive),\nthe module definition is enough for the toolchain to construct the device.  Here is a\ncomplete example of a wrapped version of this for use in RustHDL."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'# use rust_hdl::prelude::*;\n\n#[derive(LogicBlock, Default)]\npub struct ClockDriver {\n  pub clock_p: Signal<In, Clock>,\n  pub clock_n: Signal<In, Clock>,\n  pub sys_clock: Signal<Out, Clock>,\n}\n\nimpl Logic for ClockDriver {\n    // Our simulation simply forwards the positive clock to the system clock\n    fn update(&mut self) {\n        self.sys_clock.next = self.clock_p.val();\n    }\n    // RustHDL cannot determine what signals are driven based on the declaration\n    // alone.  This method identifies `sys_clock` as being driven by the internal\n    // logic of the device.\n    fn connect(&mut self) {\n        self.sys_clock.connect();\n    }\n    // Normally the `hdl` method is generated by the `derive` macro.  But in this\n    // case we implement it ourselves to wrap the Verilog code.\n     fn hdl(&self) -> Verilog {\n        Verilog::Wrapper(Wrapper {\n          code: r#"\n    // This is basically arbitrary Verilog code that lives inside\n    // a scoped module generated by RustHDL.  Whatever IP cores you\n    // use here must have accompanying core declarations in the\n    // cores string, or they will fail verification.\n    //\n    // In this simple case, we remap the names here\n    IBUFDS ibufds_inst(.I(clock_p), .B(clock_n), .O(sys_clock));\n\n"#.into(),\n    // Some synthesis tools (like [Yosys] need a blackbox declaration so they\n    // can process the Verilog if they do not have primitives in their\n    // libraries for the device.  Other toolchains will strip these out.\n          cores: r#"\n(* blackbox *)\nmodule IBUFDS(I, B, O);\n  input I;\n  input B;\n  output O;\nendmodule"#.into(),\n        })\n     }\n}\n')))}d.isMDXComponent=!0}}]);