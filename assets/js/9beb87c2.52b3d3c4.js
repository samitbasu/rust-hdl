"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[80],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},v=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=u(n),v=a,h=d["".concat(s,".").concat(v)]||d[v]||c[v]||l;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=v;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:a,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}v.displayName="MDXCreateElement"},1016:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const l={sidebar_position:99},i="Change Log",o={unversionedId:"changelog",id:"changelog",title:"Change Log",description:"v0.44.0",source:"@site/docs/changelog.md",sourceDirName:".",slug:"/changelog",permalink:"/changelog",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/changelog.md",tags:[],version:"current",sidebarPosition:99,frontMatter:{sidebar_position:99},sidebar:"tutorialSidebar",previous:{title:"Roadmap",permalink:"/roadmap"},next:{title:"References",permalink:"/references"}},s={},u=[{value:"v0.44.0",id:"v0440",level:2},{value:"v0.43.0",id:"v0430",level:2},{value:"v0.42.0",id:"v0420",level:2},{value:"v0.41.0",id:"v0410",level:2},{value:"v0.40.0",id:"v0400",level:2},{value:"v0.39.0",id:"v0390",level:2},{value:"v0.38.0",id:"v0380",level:2},{value:"v0.37.1",id:"v0371",level:2},{value:"v0.37.0",id:"v0370",level:2},{value:"v0.36.0",id:"v0360",level:2},{value:"v0.35.1",id:"v0351",level:2},{value:"v0.35.0",id:"v0350",level:2},{value:"v0.34.0",id:"v0340",level:2},{value:"v0.33.0",id:"v0330",level:2}],p={toc:u},d="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"change-log"},"Change Log"),(0,a.kt)("h2",{id:"v0440"},"v0.44.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A bunch of internal fixes for dealing with some stale crates on crates.io that\nI couldn't do anything about.  So I renamed the internal crates and split them\nup into ",(0,a.kt)("inlineCode",{parentName:"li"},"rust_hdl_lib_*"),".  As an end-user it should be transparent, and ideally\nyou only need to deal with the ",(0,a.kt)("inlineCode",{parentName:"li"},"rust-hdl")," top-level crate unless you need a\nBSP for a specific FPGA board.")),(0,a.kt)("h2",{id:"v0430"},"v0.43.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Add support for right and left shifts by different bit width amounts.  For example,\nthe following construct used to not be allowed, since RustHDL would insist that the\ntwo arguments to both the left and right shift operators be the same bitwidth.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(LogicBlock)]\nstruct Foo {\n    pub sig1: Signal<In, Bits<4>>,\n    pub sig2: Signal<In, Bits<2>>,\n    pub sig3: Signal<Out, Bits<4>>,\n}\n\nimpl Logic for Foo {\n    #[hdl_gen]\n    fn update(&mut self) {\n        self.sig3.next = self.sig1.val() << self.sig2.val(); // <-- used to require a bitcast - now it doesn't\n    }\n}\n")),(0,a.kt)("h2",{id:"v0420"},"v0.42.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Support for comparison operations on signed arguments.  Support for signed quantities is\nstill improving in RustHDL.  Now you can do:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(LogicBlock)]\nstruct Foo {\n    pub sig1: Signal<In, Signed<4>>,\n    pub sig2: Signal<In, Signed<4>>,\n    pub sig3: Signal<Out, Bit>,\n}\n\nimpl Logic for Foo {\n    #[hdl_gen]\n    fn update(&mut self) {\n        self.sig3.next = self.sig1.val() < self.sig2.val(); // <-- used to not work at all.  Now it works\n    }\n}\n")),(0,a.kt)("p",null,"The generated Verilog should have the proper ",(0,a.kt)("inlineCode",{parentName:"p"},"$signed")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"$unsigned")," decorations, but it's good to double\ncheck the output to make sure it looks reasonable."),(0,a.kt)("h2",{id:"v0410"},"v0.41.0"),(0,a.kt)("p",null,"No changes."),(0,a.kt)("h2",{id:"v0400"},"v0.40.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Refactored the I2C bus to make it slightly easier to use.  Now the bus looks like this:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(LogicInterface, Default)]\n#[join = "I2CBusReceiver"]\npub struct I2CBusDriver {\n    pub sda: OpenDrainDriver,\n    pub scl: OpenDrainDriver,\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"OpenDrainDriver")," is also a bus definition:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(LogicInterface, Default)]\n#[join = "OpenDrainReceiver"]\npub struct OpenDrainDriver {\n    pub drive_low: Signal<Out, Bit>,\n    pub line_state: Signal<In, Bit>,\n}\n')),(0,a.kt)("p",null,"This constrains (through the types) the operations that can be legally completed on an open drain pin."),(0,a.kt)("h2",{id:"v0390"},"v0.39.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"There are some issues with synthesis tools that do not properly route analog signals into the design (no names...)\nSo to be safe you should move your tristate buffers as close to the top of your design hierarchy as possible.",(0,a.kt)("br",{parentName:"li"}),"This release removed the I2C tristate buffers from the controller and moved them out.")),(0,a.kt)("h2",{id:"v0380"},"v0.38.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Clean up some of the doc tests, and remove some debug statements.  Update the homepage in the Cargo manifest to\npoint to the ",(0,a.kt)("a",{parentName:"li",href:"https://www.rust-hdl.org"},"website"),".")),(0,a.kt)("h2",{id:"v0371"},"v0.37.1"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Removed the ",(0,a.kt)("inlineCode",{parentName:"li"},"yosys"),"-based input-write detection, which erroneously flagged a legitimate case\ninvolving a tristate signal.")),(0,a.kt)("h2",{id:"v0370"},"v0.37.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Updated the simualted ADS8688 to be closer to the behavior described in the datasheet.")),(0,a.kt)("h2",{id:"v0360"},"v0.36.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Documentation improvements."),(0,a.kt)("li",{parentName:"ul"},"Add logic to the analysis pass to look for writes to the input signals.")),(0,a.kt)("h2",{id:"v0351"},"v0.35.1"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Added some additional tests for SPI modes.")),(0,a.kt)("h2",{id:"v0350"},"v0.35.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Added the simulated ADS8688 chip.")),(0,a.kt)("h2",{id:"v0340"},"v0.34.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"No new features - Manifest fixup.")),(0,a.kt)("h2",{id:"v0330"},"v0.33.0"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Fix XEM6010 support"),(0,a.kt)("li",{parentName:"ul"},"Crate cleanup"),(0,a.kt)("li",{parentName:"ul"},"Split the test code back out put the BSPs back into their own crates."),(0,a.kt)("li",{parentName:"ul"},"Update the itnegration tests for the Alchitry Cu"),(0,a.kt)("li",{parentName:"ul"},"Moved the toolchain files to the ",(0,a.kt)("inlineCode",{parentName:"li"},"fpga-support")," crate.")),(0,a.kt)("h1",{id:"older-versions"},"Older versions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Unfortunately, previous releases were not done with the ",(0,a.kt)("inlineCode",{parentName:"li"},"cargo release")," tool"),(0,a.kt)("li",{parentName:"ul"},"So I can't correlate the releases to the precise commits easily.")))}c.isMDXComponent=!0}}]);