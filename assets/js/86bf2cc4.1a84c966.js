"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[648],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),h=i,m=c["".concat(s,".").concat(h)]||c[h]||d[h]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6664:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const r={},o="Signal Type",l={unversionedId:"guide/rusthdl/signals",id:"guide/rusthdl/signals",title:"Signal Type",description:"Signals are software abstractions to represent physical wires.",source:"@site/docs/guide/rusthdl/signals.md",sourceDirName:"guide/rusthdl",slug:"/guide/rusthdl/signals",permalink:"/guide/rusthdl/signals",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/rusthdl/signals.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Operations on bits",permalink:"/guide/rusthdl/operators"},next:{title:"Simulation",permalink:"/guide/rusthdl/simulation"}},s={},u=[],p={toc:u},c="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"signal-type"},"Signal Type"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Signals are software abstractions to represent physical wires.")),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"core::signal::Signal"},"Signal"),"\ntype is generic over a couple of parameters.  The first is meant to indicate the driver of the wire.\nIn RustHDL, every wire must have exactly one driver.  It is the hardware equivalent of the\nsingle writer principle.  You can have as many readers as you want, but only one writer.  Unfortunately,\nthere are some subtleties here, and declaring ownership of a wire using the type system is\nimperfect.  Instead, we settle for a signalling mechanism of ",(0,i.kt)("em",{parentName:"p"},"intent"),".  So you mark a\nsignal as how you intend to use it in your logic.  For example, consider the following circuit:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct My8BitAdder {\n   pub input_1: Signal<In, Bits<8>>,\n   pub input_2: Signal<In, Bits<8>>,\n   pub output: Signal<Out, Bits<8>>,\n}\n")),(0,i.kt)("p",null,"In this case, the fields of the adder circuit are marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"pub")," so they can be accessed from\noutside the circuit.  The ",(0,i.kt)("a",{parentName:"p",href:"core::signal::Direction"},"Direction")," argument to the ","[Signal]"," indicates\nhow the given circuit intends to utilize the various wires.  In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"input_1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"input_2"),"\nshould be considered inputs, and ",(0,i.kt)("inlineCode",{parentName:"p"},"output")," is, obviously, an output.  As such, ",(0,i.kt)("inlineCode",{parentName:"p"},"My8BitAdder")," is\npromising you that it will drive the ",(0,i.kt)("inlineCode",{parentName:"p"},"output")," wire.  If it fails to actually do so (by leaving\nit undriven), then you will get an error when you try to use it in a design."),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("em",{parentName:"p"},"RustHDL does not allow undriven nets"),".  They are treated similarly to uninitialized memory in Rust.\nYou ",(0,i.kt)("em",{parentName:"p"},"must")," drive every net in the design.  Furthermore, you can have only one driver for each\nnet.  These two principles are core to RustHDL!")),(0,i.kt)("p",null,"The second part of a ","[Signal]"," is that it is ",(0,i.kt)("em",{parentName:"p"},"typed"),".  In general, the type signature is meant\nto convey something about the nature of the data being stored or passed.  In the case of\n",(0,i.kt)("inlineCode",{parentName:"p"},"My8BitAdder"),", it doesn't say much - only that the input is an unsigned 8-bit value.  But\nthe types can be more complicated, including collections of signals running in multiple\ndirections (as is typical for a bus or other complex interface)."),(0,i.kt)("p",null,"Signals can also be bidirectional with the ",(0,i.kt)("a",{parentName:"p",href:"core::signal::Direction::InOut"},"InOut")," designation.\nBut you typically can only use these types of signals at the edge of your device.  More on that\nelsewhere."),(0,i.kt)("p",null,"The definition of ","[Signal]"," also indicates how it should be used.  ","[Signal]","'s cannot be\nassigned to using usual semantics."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Clone, Debug)]\npub struct Signal<D: Direction, T: Synth> {\n    pub next: T,\n    pub changed: bool,\n    // Internal details omitted\n}\n")),(0,i.kt)("p",null,"To change (drive) the value of a signal, you assign to the ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," field.  To read the\nvalue of the signal (i.e. to get it's current state without driving it), you use the ",(0,i.kt)("inlineCode",{parentName:"p"},"val()")," method.\nThis is in keeping with the idea that you treat the signal differently if you want to drive\nit to some value, versus if you want to read it, as in hardware, these are different functions.\nIn most cases, you will read from ",(0,i.kt)("inlineCode",{parentName:"p"},"val()")," of the input signals, and write to the ",(0,i.kt)("inlineCode",{parentName:"p"},".next")," of the\noutput signal.  For example, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"My8BitAdder")," example, you would read from ",(0,i.kt)("inlineCode",{parentName:"p"},"input_1.val()"),"\nand from ",(0,i.kt)("inlineCode",{parentName:"p"},"input_2.val()"),", and write to ",(0,i.kt)("inlineCode",{parentName:"p"},"output.next"),".  Like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct My8BitAdder {\n   pub input_1: Signal<In, Bits<8>>,\n   pub input_2: Signal<In, Bits<8>>,\n   pub output: Signal<Out, Bits<8>>,\n}\n\nimpl Logic for My8BitAdder {\n   fn update(&mut self) {\n       self.output.next = self.input_1.val() + self.input_2.val();\n   }\n}\n")),(0,i.kt)("p",null,'In general, this is the pattern to follow.  However, there are some exceptions.  Sometimes,\nyou will want a "scratchpad" for holding intermediate results in a longer expression.\nFor example, suppose you want to logically OR a bunch of values together, but want to\nlogically shift them into different positions before doing so.  Let us assume you have\na logical block that looks like this:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct OrStuff {\n   pub val1: Signal<In, Bit>,\n   pub val2: Signal<In, Bits<4>>,\n   pub val3: Signal<In, Bits<2>>,\n   pub val4: Signal<In, Bit>,\n   pub combined: Signal<Out, Bits<8>>,\n   pad: Signal<Local, Bits<8>>,\n}\n")),(0,i.kt)("p",null,"In this case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"pad")," field (which is private to the logic) has a direction of ",(0,i.kt)("inlineCode",{parentName:"p"},"Local"),",\nwhich means it can be used to write and read from in the same circuit, as ",(0,i.kt)("em",{parentName:"p"},"long as you write first"),"!\nHence, you can do something like this in the ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," method"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"impl Logic for OrStuff {\n   fn update(&mut self) {\n      self.pad.next = 0.into(); // Write first\n      self.pad.next = self.pad.val() | bit_cast::<8,1>(self.val1.val().into()); // Now we can read and write to it\n      self.pad.next = self.pad.val() | (bit_cast::<8,4>(self.val2.val()) << 1);\n      self.pad.next = self.pad.val() | (bit_cast::<8,2>(self.val3.val()) << 5);\n      self.pad.next = self.pad.val() | (bit_cast::<8,1>(self.val4.val().into()) << 7);\n      self.combined.next = self.pad.val();\n   }\n}\n")),(0,i.kt)("p",null,'You can understand this behavior by either "folding" all of the expressions into a single\nlong expression (i.e., by eliminating ',(0,i.kt)("inlineCode",{parentName:"p"},"self.pad")," altogether) and just assigning the output\nto an expression consisting of the various inputs OR-ed together.  Nonetheless, it is\nhandy to be able to compute intermediate values and read them back elsewhere in the code."),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},".next")," should ",(0,i.kt)("em",{parentName:"p"},"never")," appear on the right hand side of an expression! The\nprocedural macro used to transform your code should check for this, and flag it as an\nerror, but just avoid even trying to do so.  Think of ",(0,i.kt)("inlineCode",{parentName:"p"},".next")," as a write-only element.")),(0,i.kt)("p",null,"The following code will fail to compile, because once we try to derive HDL from the result,\nRustHDL realizes it makes no sense."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"}," impl Logic for OrStuff {\n    #[hdl_gen]\n    fn update(&mut self) {\n       self.pad.next = 0.into(); // Write first\n       self.pad.next = self.pad.next | bit_cast::<8,1>(self.val1.val().into()); // Fails!  Can only write to .next\n       self.combined.next = self.pad.val();\n    }\n }\n")),(0,i.kt)("p",null,"Detecting the case in which you fail to write to a signal before reading from it is more complicated\nand must be done a run time.  The macro processor is not sophisticated enough to detect that case at the moment.\nHowever, it can be found when your logic is checked for correctness by the static analyzer."),(0,i.kt)("p",null,"Normally, the Verilog code generator or the Simulation engine will statically check your design for you.\nHowever, you can also check the design yourself using the ",(0,i.kt)("a",{parentName:"p",href:"core::check_error::check_all"},"check_all"),"\nfunction.  Here is an example of that check being run on a logic block that attempts to write\nto an input signal being passed into the block.  The example panics because"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(LogicBlock, Default)]\nstruct BadActor {\n  pub in1: Signal<In, Bit>,\n  pub in2: Signal<In, Bit>,\n  pub out1: Signal<Out, Bit>,\n}\n\nimpl Logic for BadActor {\n  #[hdl_gen]\n  fn update(&mut self) {\n       // This is definitely not OK\n       self.in1.next = true;\n       // This is fine\n       self.out1.next = self.in2.val();\n   }\n}\n\n// This will panic with an error of CheckError::WritesToInputs, pointing to self.in1\ncheck_all(&BadActor::default()).unwrap()\n")))}d.isMDXComponent=!0}}]);