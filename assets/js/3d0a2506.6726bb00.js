"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[336],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),p=i,h=d["".concat(l,".").concat(p)]||d[p]||m[p]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2748:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const r={},o="Simulation",s={unversionedId:"guide/rusthdl/simulation",id:"guide/rusthdl/simulation",title:"Simulation",description:"Now that you have a shiny new circuit implemented as a struct, what do you do with it?",source:"@site/docs/guide/rusthdl/simulation.md",sourceDirName:"guide/rusthdl",slug:"/guide/rusthdl/simulation",permalink:"/guide/rusthdl/simulation",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/rusthdl/simulation.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Signal Type",permalink:"/guide/rusthdl/signals"},next:{title:"Struct valued signals",permalink:"/guide/rusthdl/struct_valued"}},l={},u=[],c={toc:u},d="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"simulation"},"Simulation"),(0,i.kt)("p",null,"Now that you have a shiny new circuit implemented as a struct, what do you do with it?\nTypically, in hardware design, the first thing you do (after static analysis) is to simulate\nthe circuit.  Simulation allows you to verify the proper behavior of the circuit in software\n",(0,i.kt)("em",{parentName:"p"},"before"),' heading over to the bench to test on the physical hardware.  There is a saying\nin hardware design "success in simulation is necessary, but not sufficient for correct operation".\nOr something like that.'),(0,i.kt)("p",null,"In any case, RustHDL makes it easy to simulate your designs by allowing you to create and write\ncomplex test benches in Rust instead of in an HDL like Verilog or VHDL.  Furthermore, the\nsimulator is built in, so you do not need to use external tools for simulation.  Occasionally,\nyou may need to or want to simulate using external tools.  Currently, RustHDL can't help\nmuch there.  You can convert your design to Verilog and then import it into standard\nsimulation tools, but the testbench won't go with the design.  Maybe in the future..."),(0,i.kt)("p",null,"The simulator that is built into RustHDL is pretty basic, and easy to use.  To use it, you\nneed a circuit to simulate.  Let's create a basic 8 bit adder with a clocked register for\nthe output (and no carry):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use rust_hdl::prelude::*;   // <- shorthand to bring in all definitions\n\n//        v--- Required by RustHDL\n#[derive(LogicBlock, Default)]\nstruct MyAdder {\n    pub sig_a: Signal<In, Bits<8>>,\n    pub sig_b: Signal<In, Bits<8>>,\n    pub sig_sum: Signal<Out, Bits<8>>,\n    pub clock: Signal<In, Clock>,\n    my_reg: DFF<Bits<8>>,\n}\n\nimpl Logic for MyAdder {\n  #[hdl_gen]  // <--- don't forget this\n  fn update(&mut self) {\n       // Setup the DFF.. this macro is handy to prevent latches\n       dff_setup!(self, clock, my_reg);\n       self.my_reg.d.next = self.sig_a.val() + self.sig_b.val();\n       self.sig_sum.next = self.my_reg.q.val();\n   }\n}\n")),(0,i.kt)("p",null,"At this point, we can convert ",(0,i.kt)("inlineCode",{parentName:"p"},"MyAdder")," into Verilog and use a standard toolchain to generate\na bitfile.  However, we want to verify that the circuit operates properly.   The simplest way\nto do that would be to feed it a vector of random inputs, and make sure that the output\nmatches the sum of the inputs.  Setting up a simulation can be a little verbose, so there\nis a handy macro ","[simple_sim!]"," that works if you have only a single (top level) clock,\nand only need one test bench."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,i.kt)("strong",{parentName:"mdxAdmonitionTitle"}," An aside on ownership ")),(0,i.kt)("p",{parentName:"admonition"},"We haven't talked about the borrow checker much.  And that is because by and large, RustHDL\ndoes not use references.  So how do the testbenches work?  The key points for those of you\nfamiliar with Rust are:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"The circuit must be ","[Send]",".  All RustHDL components are ","[Send]","."),(0,i.kt)("li",{parentName:"ul"},"The simulation uses a ","[Box]"," to hold the circuit."),(0,i.kt)("li",{parentName:"ul"},"Each testbench runs in it's own thread."),(0,i.kt)("li",{parentName:"ul"},"The circuit is moved to each testbench as it runs via the endpoint."),(0,i.kt)("li",{parentName:"ul"},"The testbench then updates the circuit inputs, and checks outputs.  It is the\nsole owner of the circuit at this point.  "),(0,i.kt)("li",{parentName:"ul"},"The techbench then passes the circuit back to the simulation (moves) along with some\nindication of when it needs to see it again."),(0,i.kt)("li",{parentName:"ul"},"If a testbench is complete, it signals that it does not need to see the circuit again."),(0,i.kt)("li",{parentName:"ul"},"When all testbenches are complete (or any of them report an error), the simulation\nhalts.\nIt takes a little getting used to, but the design allows you to write concurrent testbenches\nwithout worrying about shared mutable state."))),(0,i.kt)("p",null,"So back to our adder.  The testbench should look something like this"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"set input A to some known value x"),(0,i.kt)("li",{parentName:"ul"},"set input B to some known value y"),(0,i.kt)("li",{parentName:"ul"},"wait a clock cycle"),(0,i.kt)("li",{parentName:"ul"},"check that the output matches the sum x + y"),(0,i.kt)("li",{parentName:"ul"},"loop until complete.")),(0,i.kt)("p",null,"Here is a complete example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'   use rand::{thread_rng, Rng};\n   use std::num::Wrapping;\n   // Build a set of test cases for the circuit.  Use Wrapping to emulate hardware.\n   let test_cases = (0..512)\n       .map(|_| {\n           let a_val = thread_rng().gen::<u8>();\n           let b_val = thread_rng().gen::<u8>();\n           let c_val = (Wrapping(a_val) + Wrapping(b_val)).0;\n           (\n               a_val.to_bits::<8>(),\n               b_val.to_bits::<8>(),\n               c_val.to_bits::<8>(),\n           )\n       })\n       .collect::<Vec<_>>();\n   // The clock speed doesn\'t really matter here. So 100MHz is fine.\n   let mut sim = simple_sim!(MyAdder, clock, 100_000_000, ep, {\n       let mut x = ep.init()?; // Get the circuit\n       for test_case in &test_cases {\n           // +--  This should look familiar.  Same rules as for HDL kernels\n           // v    Write to .next, read from .val()\n           x.sig_a.next = test_case.0;\n           x.sig_b.next = test_case.1;\n           // Helpful macro to delay the simulate by 1 clock cycle (to allow the output to update)\n           wait_clock_cycle!(ep, clock, x);\n           // You can use any standard Rust stuff inside the testbench.\n           println!(\n               "Test case {:x} + {:x} = {:x} (check {:x})",\n               test_case.0,\n               test_case.1,\n               x.sig_sum.val(),\n               test_case.2\n           );\n           // The `sim_assert_eq` macro stops the simulation gracefully.\n           sim_assert_eq!(ep, x.sig_sum.val(), test_case.2, x);\n       }\n       // When the testbench is complete, call done on the endpoint, and pass the circuit back.\n       ep.done(x)\n   });\n   // Run the simulation - needs a boxed circuit, and a maximum duration.\n   sim.run(MyAdder::default().into(), sim_time::ONE_MILLISECOND)\n       .unwrap();\n')),(0,i.kt)("p",null,"The above should write the following to your console (your numbers will be different)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"Test case 5d + 98 = f5 (check f5)\nTest case 3b + 44 = 7f (check 7f)\nTest case 5d + b0 = 0d (check 0d)\nTest case f8 + 38 = 30 (check 30)\nTest case 73 + b5 = 28 (check 28)\nTest case 1b + e5 = 00 (check 00)\nTest case c1 + 89 = 4a (check 4a)\netc...\n")),(0,i.kt)("p",null,"You can also generate a trace of the circuit using the ",(0,i.kt)("inlineCode",{parentName:"p"},"vcd")," (Value Change Dump) format, and\nread the output using ",(0,i.kt)("inlineCode",{parentName:"p"},"gtkwave")," or some other ",(0,i.kt)("inlineCode",{parentName:"p"},"vcd")," viewer.  RustHDL includes a simple\n",(0,i.kt)("inlineCode",{parentName:"p"},"vcd")," renderer for convenience, but its pretty basic, and mostly for creating documentation\nexamples.  It does have the advantage of being callable directly from your testbench in case\nyou need some visual verification of your circuit.  "),(0,i.kt)("p",null,"We can make a one line change to our previous example, and generate a ",(0,i.kt)("inlineCode",{parentName:"p"},"vcd"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'   // Run the simulation - needs a boxed circuit, and a maximum duration.\n   sim.run_to_file(\n       MyAdder::default().into(),\n       sim_time::ONE_MILLISECOND,\n       &vcd_path!("my_adder.vcd"),\n   )\n   .unwrap();\n   vcd_to_svg(\n       &vcd_path!("my_adder.vcd"),\n       "images/my_adder.svg",\n       &[\n           "uut.clock",\n           "uut.sig_a",\n           "uut.sig_b",\n           "uut.my_reg.d",\n           "uut.my_reg.q",\n           "uut.sig_sum",\n       ],\n       0,\n       100 * sim_time::ONE_NANOSECOND,\n   )\n   .unwrap()\n')),(0,i.kt)("p",null,"The result of that simulation is here.\n",(0,i.kt)("img",{parentName:"p",src:"https://github.com/samitbasu/rust-hdl/raw/main/rust-hdl/images/my_adder.svg",alt:"my_adder_sim"}),"\nNote that the digital flip flop copies it's input from ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," on the leading edge of the clock."))}m.isMDXComponent=!0}}]);