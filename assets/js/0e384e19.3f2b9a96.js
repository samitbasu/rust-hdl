"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[671],{9881:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var a=t(7462),o=(t(7294),t(3905)),i=t(2004);const l={sidebar_position:1},r="Blinky on Alchitry CU",s={unversionedId:"intro",id:"intro",title:"Blinky on Alchitry CU",description:"Let's go from an empty setup to a functioning blinking LED on an actual FPGA!  Blinking an LED is a time-honored tradition of demonstrating that you can go from source to somehting that understands",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/intro",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Quickstart for Simulation",permalink:"/simulation"}},u={},c=[{value:"Mise en Place (Prerequisites)",id:"mise-en-place-prerequisites",level:2},{value:"The FPGA board",id:"the-fpga-board",level:3},{value:"The host OS",id:"the-host-os",level:3},{value:"Rust basics",id:"rust-basics",level:3},{value:"Code Editor",id:"code-editor",level:3},{value:"FPGA Toolchain",id:"fpga-toolchain",level:3},{value:"Ready Set Go",id:"ready-set-go",level:2},{value:"Just the Verilog, Ma&#39;am",id:"just-the-verilog-maam",level:2}],d={toc:c},p="wrapper";function h(e){let{components:n,...l}=e;return(0,o.kt)(p,(0,a.Z)({},d,l,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"blinky-on-alchitry-cu"},"Blinky on Alchitry CU"),(0,o.kt)("p",null,"Let's go from an empty setup to a functioning blinking LED on an actual FPGA!  Blinking an LED is a time-honored tradition of demonstrating that you can go from source to somehting that understands\nthe hardware it is running on."),(0,o.kt)("h2",{id:"mise-en-place-prerequisites"},"Mise en Place (Prerequisites)"),(0,o.kt)("p",null,"Hardware projects can be a little more complicated than pure software ones.  So let's look at the prerequisites for this tutorial."),(0,o.kt)("h3",{id:"the-fpga-board"},"The FPGA board"),(0,o.kt)("p",null,"In principle, all you need is an FPGA board with an LED that you know how to program.  There are a number\nof hardware specific bits and pieces that you need to get right for RustHDL to actually work on you device\nof interest.  In particular, knowing what FPGA is being used is not sufficient in and of itself.  You\nneed to know how it was configured and connected to make it do things.  In any case, for this tutorial,\nlet's start with the ",(0,o.kt)("a",{parentName:"p",href:"https://www.sparkfun.com/products/16526"},"Alchitry Cu")," board.  It's reasonably inexpensive, very well constructed and designed, and generally available.  But adapting this tutorial to other boards is quite straightforward.  Here is a pic of the Alchitry board ",(0,o.kt)("img",{alt:"Alchitry board",src:t(7649).Z,width:"600",height:"600"}),"."),(0,o.kt)("h3",{id:"the-host-os"},"The host OS"),(0,o.kt)("p",null,"With the exception of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/YosysHQ/yosys"},"Yosys"),", I do not know of FPGA tooling that runs on\nMac OS X.  So I would recommending using either Linux or Windows for now.  This tutorial will assume Linux\n(and comfort with the command line).  The exact Linux distribution doesn't matter per se, but the host OS\nwill need to provide tools that Rust does not.  And those will require the host OS package manager to be\ninvolved.  For now, I've picked an Ubuntu distribution."),(0,o.kt)("h3",{id:"rust-basics"},"Rust basics"),(0,o.kt)("p",null,"I would say that RustHDL requires ",(0,o.kt)("inlineCode",{parentName:"p"},"basic")," understanding of how to code in Rust.  If you are comfortable with"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Strong types"),(0,o.kt)("li",{parentName:"ul"},"Algrbraic types (enums)"),(0,o.kt)("li",{parentName:"ul"},"Matching"),(0,o.kt)("li",{parentName:"ul"},"Basic expressions"),(0,o.kt)("li",{parentName:"ul"},"Value types")),(0,o.kt)("p",null,"You should be good to go \ud83d\udc4d.  You do not need to worry about lifetimes, references, or any of the more intermediate concepts.  I strongly recommend this ",(0,o.kt)("em",{parentName:"p"},"not")," be your first experience with Rust.  That should come\nfrom the ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/book"},"book"),".  Once you have gotten an handle on that, this should\nall seem quite simple."),(0,o.kt)("p",null,"I will assume, for example, you have already installed ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo, rustup, rust, etc.")," "),(0,o.kt)("h3",{id:"code-editor"},"Code Editor"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"}," This is important! "),"  Let's face it.  Generally, IDEs for HDLs are pretty rough.  There aren't enough HDL users to really stimulate the ecosystem and get focus on good tooling.  This is ",(0,o.kt)("strong",{parentName:"p"}," not ")," the case for RustHDL!  RustHDL uses Rust's syntax, and the analysis tools are capable of understanding most (if not all) of what RustHDL does under the hood.  As a result, you get great features like "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"code completion"),(0,o.kt)("li",{parentName:"ul"},"syntax highlighting"),(0,o.kt)("li",{parentName:"ul"},"warning and errors"),(0,o.kt)("li",{parentName:"ul"},"go to definition/declarations etc")),(0,o.kt)("p",null,"even ",(0,o.kt)("em",{parentName:"p"},"inside")," your HDL code!  You can even use ",(0,o.kt)("inlineCode",{parentName:"p"},"vim")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"emacs")," with these tools if you want to.  To me,\nthe ability to piggy-back \ud83d\udc16 on the broader community for things like IDE support are one of the big\npluses of working in RustHDL instead of something more domain specific.  If you need help getting\nset up, this ",(0,o.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/docs/languages/rust"},"page")," from the vscode team is a great place to start."),(0,o.kt)("h3",{id:"fpga-toolchain"},"FPGA Toolchain"),(0,o.kt)("p",null,"Beware the slings and arrows of outrageous FPGA toolchains!  There are many hurdles here, and progress is slow.  Suffice to say things are getting better, but you may still need to deal with a legacy toolchain.  The\nAlchitry CU uses the iCE40HX FPGA from Lattice, and it is well documented by ",(0,o.kt)("a",{parentName:"p",href:"http://www.clifford.at/icestorm/"},"Project IceStorm"),".  Installation with modern distros is simple.  For Ubuntu, it's"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"sudo apt install fpga-icestorm\n")),(0,o.kt)("p",null,"Note that you need a place and route tool.  The one originally used (",(0,o.kt)("inlineCode",{parentName:"p"},"arachne"),") is no longer supported.  So I went ahead and also installed the ",(0,o.kt)("inlineCode",{parentName:"p"},"nextpnr-ice40")," package."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"sudo apt install nextpnr-ice40\n")),(0,o.kt)("h2",{id:"ready-set-go"},"Ready Set Go"),(0,o.kt)("p",null,"With everything in place, we can get started, and it will come together quickly.  First, we create a new\nRust project of the binary type."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"samitbasu@samitbasu-virtual-machine:~/Devel$ cargo new blinky\n     Created binary (application) `blinky` package\n")),(0,o.kt)("p",null,"Next, we add the ",(0,o.kt)("inlineCode",{parentName:"p"},"rust-hdl")," meta package as a dependency.  You will need the ",(0,o.kt)("inlineCode",{parentName:"p"},"fpga")," feature"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"samitbasu@samitbasu-virtual-machine:~/Devel/blinky$ cargo add rust-hdl --features fpga\n    Updating crates.io index\n      Adding rust-hdl v0.45.0 to dependencies.\n             Features:\n             + fpga\nsamitbasu@samitbasu-virtual-machine:~/Devel/blinky$ \n")),(0,o.kt)("p",null,"We will also need the board support package for the Alchitry Cu board.  So lets add that too"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"samitbasu@samitbasu-virtual-machine:~/Devel/blinky$ cargo add rust-hdl-bsp-alchitry-cu\n    Updating crates.io index\n      Adding rust-hdl-bsp-alchitry-cu v0.45.0 to dependencies.\nsamitbasu@samitbasu-virtual-machine:~/Devel/blinky$ \n")),(0,o.kt)("p",null,"Next, we need to replace the contents of ",(0,o.kt)("inlineCode",{parentName:"p"},"main.rs")," with the following"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use rust_hdl::prelude::*;\nuse rust_hdl_bsp_alchitry_cu::pins::CLOCK_SPEED_100MHZ;\nuse rust_hdl_bsp_alchitry_cu::{pins, synth};\nuse std::time::Duration;\n\n#[derive(LogicBlock)]\npub struct Blinky {\n  pulser: Pulser,\n  clock: Signal<In, Clock>,\n  leds: Signal<Out, Bits<8>>,\n}\n\nimpl Logic for Blinky {\n  #[hdl_gen]\n  fn update(&mut self) {\n    self.pulser.enable.next = true;\n    self.pulser.clock.next = self.clock.val();\n    self.leds.next = 0x00.into();\n    if self.pulser.pulse.val() {\n      self.leds.next = 0xAA.into();\n    }\n  }\n}\n\nimpl Default for Blinky {\n  fn default() -> Self {\n    let pulser = Pulser::new(CLOCK_SPEED_100MHZ.into(), 1.0, Duration::from_millis(250));\n    Blinky {\n      pulser,\n      clock: pins::clock(),\n      leds: pins::leds(),\n    }\n  }\n}\n\nfn main() {\n    let uut = Blinky::default();\n    synth::generate_bitstream(uut, "firmware/blinky")\n}\n')),(0,o.kt)("p",null,"That's it!  Now to build firmware, we return to the command line"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"samitbasu@samitbasu-virtual-machine:~/Devel/blinky$ cargo run\n   Finished dev [unoptimized + debuginfo] target(s) in 15.74s\n   Running `target/debug/blinky`\nsamitbasu@samitbasu-virtual-machine:~/Devel/blinky$ \n")),(0,o.kt)("p",null,"The output directory ",(0,o.kt)("inlineCode",{parentName:"p"},"firmware/blinky")," contains our ",(0,o.kt)("inlineCode",{parentName:"p"},"top.bit")," firmware file, that we can flash onto the Alchitry using the ",(0,o.kt)("inlineCode",{parentName:"p"},"iceprog")," tool:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"samitbasu@samitbasu-virtual-machine:~/Devel/blinky$ iceprog firmware/blinky/top.bin \ninit..\ncdone: high\nreset..\ncdone: low\nflash ID: 0xEF 0x40 0x16 0x00\nfile size: 135100\nerase 64kB sector at 0x000000..\nerase 64kB sector at 0x010000..\nerase 64kB sector at 0x020000..\nprogramming..\ndone.                 \nreading..\nVERIFY OK             \ncdone: high\nBye.\nsamitbasu@samitbasu-virtual-machine:~/Devel/blinky$ \n")),(0,o.kt)("p",null,"Watch for blinking!"),(0,o.kt)(i.Z,{playing:!0,controls:!0,url:"img/blinky.mp4",mdxType:"ReactPlayer"}),(0,o.kt)("p",null,"Needs a few emoji: \ud83c\udf89\ud83c\udf88\ud83e\udd80, but most importantly, \ud83d\ude01!"),(0,o.kt)("h2",{id:"just-the-verilog-maam"},"Just the Verilog, Ma'am"),(0,o.kt)("p",null,"It's possible that you just want the Verilog associated with your RustHDL design.\nIn that case, you simply:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Instantiate the struct so it reflects what you want for the top level"),(0,o.kt)("li",{parentName:"ul"},"call ",(0,o.kt)("inlineCode",{parentName:"li"},"connect_all")," on it to connect up the internal wires"),(0,o.kt)("li",{parentName:"ul"},"Pass it to ",(0,o.kt)("inlineCode",{parentName:"li"},"generate_verilog")," that returns a string.")),(0,o.kt)("p",null,"So for our ",(0,o.kt)("inlineCode",{parentName:"p"},"blinky")," example, replace ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," with the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut uut = Blinky::default();\n    uut.connect_all();\n    let vlog = generate_verilog(&uut);\n    println!("{vlog}");\n}\n')),(0,o.kt)("p",null,"If we ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo run"),", we now get"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"[samitbasu@sparkle-squid blinky]$ cargo run\n   Compiling blinky v0.1.0 (/home/samitbasu/Devel/junk/blinky)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.74s\n     Running `target/debug/blinky`\n")),(0,o.kt)("p",null,"The output for the current release of RustHDL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-verilog"},"module top(clock,leds);\n    \n    // Module arguments\n    input wire  clock;\n    output reg  [7:0] leds;\n    \n    // Stub signals\n    reg  pulser$clock;\n    reg  pulser$enable;\n    wire  pulser$pulse;\n    \n    // Sub module instances\n    top$pulser pulser(\n        .clock(pulser$clock),\n        .enable(pulser$enable),\n        .pulse(pulser$pulse)\n    );\n    \n    // Update code\n    always @(*) begin\n        pulser$enable = 1'b1;\n        pulser$clock = clock;\n        leds = 32'h0;\n        if (pulser$pulse) begin\n            leds = 32'haa;\n        end\n    end\n    \nendmodule // top\n\n\nmodule top$pulser(clock,enable,pulse);\n    \n    // Module arguments\n    input wire  clock;\n    input wire  enable;\n    output reg  pulse;\n    \n    // Stub signals\n    reg  strobe$enable;\n    wire  strobe$strobe;\n    reg  strobe$clock;\n    reg  shot$trigger;\n    wire  shot$active;\n    reg  shot$clock;\n    wire  shot$fired;\n    \n    // Sub module instances\n    top$pulser$strobe strobe(\n        .enable(strobe$enable),\n        .strobe(strobe$strobe),\n        .clock(strobe$clock)\n    );\n    top$pulser$shot shot(\n        .trigger(shot$trigger),\n        .active(shot$active),\n        .clock(shot$clock),\n        .fired(shot$fired)\n    );\n    \n    // Update code\n    always @(*) begin\n        strobe$clock = clock;\n        shot$clock = clock;\n        strobe$enable = enable;\n        shot$trigger = strobe$strobe;\n        pulse = shot$active;\n    end\n    \nendmodule // top$pulser\n\n\nmodule top$pulser$shot(trigger,active,clock,fired);\n    \n    // Module arguments\n    input wire  trigger;\n    output reg  active;\n    input wire  clock;\n    output reg  fired;\n    \n    // Constant declarations\n    localparam  duration = 32'h17d7840;\n    \n    // Stub signals\n    reg  [31:0] counter$d;\n    wire  [31:0] counter$q;\n    reg  counter$clock;\n    reg  state$d;\n    wire  state$q;\n    reg  state$clock;\n    \n    // Sub module instances\n    top$pulser$shot$counter counter(\n        .d(counter$d),\n        .q(counter$q),\n        .clock(counter$clock)\n    );\n    top$pulser$shot$state state(\n        .d(state$d),\n        .q(state$q),\n        .clock(state$clock)\n    );\n    \n    // Update code\n    always @(*) begin\n        counter$clock = clock;\n        state$clock = clock;\n        counter$d = counter$q;\n        state$d = state$q;\n        if (state$q) begin\n            counter$d = counter$q + 32'h1;\n        end\n        fired = 1'b0;\n        if (state$q && (counter$q == duration)) begin\n            state$d = 1'b0;\n            fired = 1'b1;\n        end\n        active = state$q;\n        if (trigger) begin\n            state$d = 1'b1;\n            counter$d = 32'h0;\n        end\n    end\n    \nendmodule // top$pulser$shot\n\n\nmodule top$pulser$shot$counter(d,q,clock);\n    \n    // Module arguments\n    input wire  [31:0] d;\n    output reg  [31:0] q;\n    input wire  clock;\n    \n    // Update code (custom)\n    initial begin\n       q = 32'h0;\n    end\n    \n    always @(posedge clock) begin\n       q <= d;\n    end\n          \nendmodule // top$pulser$shot$counter\n\n\nmodule top$pulser$shot$state(d,q,clock);\n    \n    // Module arguments\n    input wire  d;\n    output reg  q;\n    input wire  clock;\n    \n    // Update code (custom)\n    initial begin\n       q = 1'h0;\n    end\n    \n    always @(posedge clock) begin\n       q <= d;\n    end\n          \nendmodule // top$pulser$shot$state\n\n\nmodule top$pulser$strobe(enable,strobe,clock);\n    \n    // Module arguments\n    input wire  enable;\n    output reg  strobe;\n    input wire  clock;\n    \n    // Constant declarations\n    localparam  threshold = 32'h5f5e100;\n    \n    // Stub signals\n    reg  [31:0] counter$d;\n    wire  [31:0] counter$q;\n    reg  counter$clock;\n    \n    // Sub module instances\n    top$pulser$strobe$counter counter(\n        .d(counter$d),\n        .q(counter$q),\n        .clock(counter$clock)\n    );\n    \n    // Update code\n    always @(*) begin\n        counter$clock = clock;\n        counter$d = counter$q;\n        if (enable) begin\n            counter$d = counter$q + 32'h1;\n        end\n        strobe = enable & (counter$q == threshold);\n        if (strobe) begin\n            counter$d = 32'h1;\n        end\n    end\n    \nendmodule // top$pulser$strobe\n\n\nmodule top$pulser$strobe$counter(d,q,clock);\n    \n    // Module arguments\n    input wire  [31:0] d;\n    output reg  [31:0] q;\n    input wire  clock;\n    \n    // Update code (custom)\n    initial begin\n       q = 32'h0;\n    end\n    \n    always @(posedge clock) begin\n       q <= d;\n    end\n          \nendmodule // top$pulser$strobe$counter\n")))}h.isMDXComponent=!0},7649:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/16526-Alchitry_Cu_FPGA_Development_Board__Lattice_iCE40_HX_-03-01fc8352c615d73c36ef8053f9475db3.jpg"}}]);