"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[297],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(r),h=n,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||i;return r?a.createElement(m,o(o({ref:t},p),{},{components:r})):a.createElement(m,o({ref:t},p))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:n,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},524:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=r(7462),n=(r(7294),r(3905));const i={},o="High Speed I/O",s={unversionedId:"guide/fpga/high-speed-io",id:"guide/fpga/high-speed-io",title:"High Speed I/O",description:"Another area where FPGAs excel is at high speed predictable I/O.  Suppose you are",source:"@site/docs/guide/fpga/high-speed-io.md",sourceDirName:"guide/fpga",slug:"/guide/fpga/high-speed-io",permalink:"/guide/fpga/high-speed-io",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/fpga/high-speed-io.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Deterministic systems",permalink:"/guide/fpga/deterministic-systems"},next:{title:"True Parallelism (The Kitchen Analogy)",permalink:"/guide/fpga/kitchen-analogy"}},l={},c=[],p={toc:c},u="wrapper";function d(e){let{components:t,...r}=e;return(0,n.kt)(u,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"high-speed-io"},"High Speed I/O"),(0,n.kt)("p",null,"Another area where FPGAs excel is at high speed predictable I/O.  Suppose you are\nbuilding yourself a radio, and want to sample some intermediate signal at a couple\nof MSPS (Million samples per second).  It happens.  That means that some dedicated\ncircuitry is going to be sending you data at some pretty high rate.  How high?",(0,n.kt)("br",{parentName:"p"}),"\n","Well, assume the samples are 16 bits each, and you are shooting for 2 MSPS.  That\nmeans you need about 32 Mbits/second to keep up with the incoming data.  Sounds easy,\nright?  I mean, we have ubiquitous 1 Gbit/second ethernet everywhere.  What's a\n32 Mbit signal stream?"),(0,n.kt)("p",null,"But it is actually not so easy.  That chip (an analog digital converter chip) will send\na constant stream of data at high speed.  You might be able to read that with a microcontroller,\nbut it won't be easy.  Even if the chip satisfies some standard protocol, like SPI,\nit may not send data the way your hardware SPI controller expects.  The chip manufacturer\nhas probably assumed that this is Your Problem."),(0,n.kt)("p",null,"FPGAs can solve these types of problems through a combination of 3 pieces:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"They typically have dedicated circuitry that deals with high speed I/O, and most high\nspeed interfaces operate the same or similar way.  These circuits speak the various electrical\nprotocols used by standards such as LVDS, etc."),(0,n.kt)("li",{parentName:"ul"},"They allow you to quickly pack high speed, narrow data streams, into lower speed, wide\ndata streams.  A standard technique is to take that 32 Mbit/second stream and turn it\ninto a 2 million words/second stream, where the words are 16 bits wide."),(0,n.kt)("li",{parentName:"ul"},"They typically contain hardware to do the reverse too - to take wide, slow streams and\nconvert them back into fast, narrow ones.")))}d.isMDXComponent=!0}}]);