"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[191],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=u(n),m=a,p=h["".concat(l,".").concat(m)]||h[m]||d[m]||i;return n?o.createElement(p,r(r({ref:t},c),{},{components:n})):o.createElement(p,r({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:a,r[1]=s;for(var u=2;u<i;u++)r[u]=n[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4253:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var o=n(7462),a=(n(7294),n(3905));const i={},r="Python Based Approaches",s={unversionedId:"guide/programming/migen",id:"guide/programming/migen",title:"Python Based Approaches",description:"MyHDL",source:"@site/docs/guide/programming/migen.md",sourceDirName:"guide/programming",slug:"/guide/programming/migen",permalink:"/guide/programming/migen",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/programming/migen.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Lucid",permalink:"/guide/programming/lucid"},next:{title:"Verilog",permalink:"/guide/programming/verilog"}},l={},u=[{value:"MyHDL",id:"myhdl",level:2},{value:"MiGen, FHDL",id:"migen-fhdl",level:2},{value:"Python code cannot be known to be correct or incorrect unless it is tested.",id:"python-code-cannot-be-known-to-be-correct-or-incorrect-unless-it-is-tested",level:3},{value:"Generated code needs to be understandable.",id:"generated-code-needs-to-be-understandable",level:3},{value:"Simulation speed matters",id:"simulation-speed-matters",level:3}],c={toc:u},h="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"python-based-approaches"},"Python Based Approaches"),(0,a.kt)("h2",{id:"myhdl"},"MyHDL"),(0,a.kt)("p",null,"MyHDL is an attempt to do something entirely different.  MyHDL uses Python as the\nlanguage of choice, and uses an asynchronous function model for capturing expected\nbehavior.  The Python library then translates those functions into Verilog that you\nfeed to your toolchain.  MyHDL is meant to tackle not just FPGAs, but ASICs and as\nsuch, can be a bit limiting for FPGA use, since FPGAs have features that ASICs do\nnot (generally) have, and those features can make a big difference in the difficulty\nof describing your design."),(0,a.kt)("h2",{id:"migen-fhdl"},"MiGen, FHDL"),(0,a.kt)("p",null,"Unfortunately, I have no direct experience with either of these.  They live firmly\nin the Python ecosystem, and they have built some pretty impressive libraries of\nfunctionality.  While I spent some time writing firmware in MyHDL, I left the Python\necosystem and started working on RustHDL before I fully explored all the possibilities."),(0,a.kt)("p",null,"I did note a couple of challenges with my Python based firmware:"),(0,a.kt)("h3",{id:"python-code-cannot-be-known-to-be-correct-or-incorrect-unless-it-is-tested"},"Python code cannot be known to be correct or incorrect unless it is tested."),(0,a.kt)("p",null,"That means that no matter how simple the function, you don't know if it is even\nsyntactically valid until you have exercised it in some way.  I'm sure that's a good thing, but I\nfound it annoying.  It was difficult enough to focus on the correctness of the design\nand the logic without worrying that somewhere I had misspelled a signal name, and\nso that branch would fail when invoked.  One can argue that all code must be\ntested to be correct, and that is certainly true.  But the contracts provided\nby strongly typed languages like Rust mean you can focus your energy on the\ntests that look for edge cases and behavior problems."),(0,a.kt)("h3",{id:"generated-code-needs-to-be-understandable"},"Generated code needs to be understandable."),(0,a.kt)("p",null,'There are still differences between CPUs and FPGAs we have not discussed, but it\nis entirely possible/trivial to design an FPGA circuit with a few lines of code that\ncannot actually be constructed.  If your designs are strict compositions of existing\npieces (SoC style), you may never encounter this problem.  And for many problems\nconnecting high level constructs together to accomplish an overall goal or pattern\nis a reasonable solution.  However, if you are building your own components, with\ncustomized behavior, then you will sooner or later, write something that cannot\nbe built.  For example, you will ask the FPGA to build a circuit that\nmultiplies integers, dynamically indexes into a register, or performs some\nweird operation called "division" that the FPGA simply cannot do.  Or you may\ncram-fooey too much into a single operation, forcing the entire FPGA to crawl along.\nThe food factory analogy is relevant here too (beginning to think I should have\njust written a book titled "The FPGA Food Factory Analogy").  In a normal factory,\nyou typically establish a "critical time" - which is how much time the longest\nindivisible operation in your process takes to complete.  Let\'s say this is 20 minutes\nbecause the longest operation involves some intricate process.  That 20 minutes\nsets the standard for every other step in the process.  For a simple, linear\ntype of workflow, you assume each step in the process takes no more than 20 minutes.'),(0,a.kt)("p",null,"As a result, you can advance the state of the food pipeline every 20 minutes\nlike clock work.  This is precisely how FPGAs are designed and programmed.  Ok,\nnot precisely, but close enough.  If you add a step to the process that takes 30 minutes,\nthen the whole process must slow down by 50%.  The same thing can happen when\nprogramming an FPGA.  The tools will try their hardest to do what you ask, but you may end\nup with a step in which all kinds of complexity are being called into order to\nsatisfy what you asked for."),(0,a.kt)("p",null,'Most of the time, this is not what you want, and not what you intended.  It\'s usually\na case of incorrect expression of the idea ("when I said make a salad, I meant just\nsome lettuce on the side"), or the idea itself needs to be broken down into smaller\nsimpler steps ("Let me set up a line to make salads and then inject them at this point").\nIn the later, you have "pipelined" the process.  Taken a single step ("make a salad"),\nand broken it down into lots of smaller steps ("chop tomatoes").  These smaller steps\nwould then get their own stations in the food factory, and you could run at 20 minute\nintervals again.'),(0,a.kt)("p",null,"My point (yes, I had one), is that the information about where your instructions\nare too complicated will come from the FPGA toolchain, and not from your high level\nlanguage.  A few lines in Python can easily generate a design that looks great and\nsimulates in Python just fine, but causes your toolchain to become indignant.",(0,a.kt)("br",{parentName:"p"}),"\n","When this happens, you must look at the Verilog code, since that is the contract\nbetween you and the toolchain.  "),(0,a.kt)("p",null,"This is where you will pay the price for the high level simplicity.  By abstracting\naway the details, you could very well end up with ",(0,a.kt)("inlineCode",{parentName:"p"},"widget_0_1_2_3_4_5"),' violating\nsome hardware constraint, without any idea what that means.  This is a common problem\nwith translating to Verilog.  You often have to replicate, and "squash" hierarchies to\nget it to behave the way you want/expect.  As a result, you end up with funkafied\nidentifiers, monolothic mega-functions, global everythings, and all kinds of\nnastiness.  This is fine, as long as everything works as intended.  But if it doesn\'t,\nyou can be left with no clue as to what went wrong and why.'),(0,a.kt)("h3",{id:"simulation-speed-matters"},"Simulation speed matters"),(0,a.kt)("p",null,"One of the important differences between hardware and software design is the importance\nof test cases.  To test a hardware design, means you must either simulate it, or\nsynthesize it (or both).  If you simulate a design, it means that you ignore some\nof the lower level details of how the hardware actually works, and try to verify that\nthe behavior of a circuit matches your expectations.  This can take a really, really\nlong time.  If you are within a factor of 100 to 1000 of a real FPGA, you are doing well.\nA fast mutli-GHz, multi-core CPU can struggle to model a massively parallel design\nrunning at a glacial 100MHz.  That 10-20X difference in speed can easily be\noverwhelmed by the fact that your CPU (when it's simulating an FPGA) can only perform\na handful of operations at a time, while that FPGA design may have hundreds or\nthousands of operations running simultaneously.  On top of that, FPGA simulation is\na scary non-linear problem, and requires iterations.  It's hard to parallelize\n(ironically), and a ton of work has gone into making FPGA simulation performant."),(0,a.kt)("p",null,"Can I illustrate my point?  Sure.  Why not.  Let's say we want to go back to the\ntemperature measurement problem.  This time, we want to measure the temperature\nover some long wires, using a digital protocol (like SPI or I2C).  Because the temperature\nsensor is sitting far away, it's possible that occaisionally, the temperature\nchip will not answer our request for a temperature reading.  In those cases, our\nrecovery procedure is to wait up to 1 second, and then try again."),(0,a.kt)("p",null,"Easy enough.  Let's assume our FPGA clock is running at 100 MHz, so that a 1 second\nwait is simply the amount of time it takes to count to 100 million.  Hmm...\nThat can take a simulator a couple of minutes to do, at least for anything nontrivial.\nI know!  I'll just shorten the count from 100 million to something smaller for\ntest purposes.  I'll use 100 thousand as the count instead of 100 million.  That's\nquick to simulate, right?"),(0,a.kt)("p",null,"Sure!  And when you changed the count how did you do it?  Did you change the\nsize of the counter?  Does it have enough bits for the actual applications?\nIs the constant hard coded?  Or passed in?  Do you see the problem?"),(0,a.kt)("p",null,"Modifying designs to make them faster to test is usually a bad idea.  It may be\nunavoidable, but in general, testing the same code you plan to run on the hardware\nis the best way of making sure it is actually correct.  So a simulation that runs\n10X or 100X faster can make a difference in how much of your code you can realistically\ntest, and that matters!"))}d.isMDXComponent=!0}}]);