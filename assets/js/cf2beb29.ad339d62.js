"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[472],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),f=r,m=p["".concat(s,".").concat(f)]||p[f]||d[f]||i;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},4719:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={},o="Interfaces",l={unversionedId:"guide/rusthdl/interfaces",id:"guide/rusthdl/interfaces",title:"Interfaces",description:"One area you will encouter as your circuits become more complex is that the interfaces",source:"@site/docs/guide/rusthdl/interfaces.md",sourceDirName:"guide/rusthdl",slug:"/guide/rusthdl/interfaces",permalink:"/guide/rusthdl/interfaces",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/rusthdl/interfaces.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"High Level Synthesis",permalink:"/guide/rusthdl/high_level_synthesis"},next:{title:"Loops and Arrays",permalink:"/guide/rusthdl/loops"}},s={},u=[],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"interfaces"},"Interfaces"),(0,r.kt)("p",null,"One area you will encouter as your circuits become more complex is that the interfaces\nto those circuits will become increasingly complicated.  To demonstrate, suppose you\nhave a circuit that consumes a sequence of 16-bit integers via a FIFO interface.  The\ncircuit has some flow control signals because it cannot consume them every clock\ncycle (For Reasons).  Suppose also that you have a data producer circuit that will\nproduce 16-bit integers and you want to connect these two together.  A natural\nFIFO interface would look like this"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n struct MyFIFO {\n     pub data_to_fifo: Signal<In, Bits<16>>,\n     pub write: Signal<In, Bits<16>>,\n     pub full: Signal<Out, Bit>,\n     pub overflow: Signal<Out, Bit>,\n }\n\n struct DataWidget {\n     pub data_to_fifo: Signal<Out, Bits<16>>,\n     pub write: Signal<Out, Bits<16>>,\n     pub full: Signal<In, Bit>,\n     pub overflow: Signal<In, Bit>,\n }\n\n struct Foo {\n    producer: DataWidget,\n    consumer: MyFIFO,\n }\n")),(0,r.kt)("p",null,"Now, we want to connect the output of the DataWidget (all 4 signals!) to the corresponding\nsignals on ",(0,r.kt)("inlineCode",{parentName:"p"},"MyFIFO"),".  Keep in mind that the order of assignment is irrelevant, but which\nsignal appears on the LHS vs RHS ",(0,r.kt)("em",{parentName:"p"},"is")," important.  In the ",(0,r.kt)("inlineCode",{parentName:"p"},"impl Logic")," block for ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo"),",\nour HDL kernel will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl Logic for Foo {\n  #[hdl_gen]\n  fn update(&mut self) {\n     self.consumer.data_to_fifo.next = self.producer.data_to_fifo.val();\n     self.consumer.write.next = self.producer.write.val();\n     self.producer.full.next = self.consumer.full.val();\n     self.producer.overflow.next = self.consumer.overflow.val();\n  }\n}\n")),(0,r.kt)("p",null,"This is basically boilerplate at this point, and typing that in and getting it right\nis error prone and tedious.  Fortunately, RustHDL can help!  RustHDL includes the\nconcept of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Interface"),", which is basically a bus.  An ",(0,r.kt)("inlineCode",{parentName:"p"},"Interface")," is generally a\npair of structs that contain signals of complementary directions and a ",(0,r.kt)("inlineCode",{parentName:"p"},"#[derive]"),"\nmacro that autogenerates a bunch of boilerplate.  To continue on with our previous\nexample, we could define a pair of ",(0,r.kt)("inlineCode",{parentName:"p"},"struct"),"s for the write interface of the FIFO"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(LogicInterface)]     // <- Note the LogicInterface, not LogicBlock\n#[join = "MyFIFOWriteSender"] // <- Name of the "mating" interface\nstruct MyFIFOWriteReceiver {\n    pub data_to_fifo: Signal<In, Bits<16>>,\n    pub write: Signal<In, Bit>,\n    pub full: Signal<Out, Bit>,\n    pub overflow: Signal<Out, Bit>,\n}\n\n#[derive(LogicInterface)]       // <- Also here\n#[join = "MyFIFOWriteReceiver"] // <- Name of the "mating" interface\nstruct MyFIFOWriteSender {\n   pub data_to_fifo: Signal<Out, Bits<16>>,\n   pub write: Signal<Out, Bit>,\n   pub full: Signal<In, Bit>,\n   pub overflow: Signal<In, Bit>\n}\n')),(0,r.kt)("p",null,"The names of the fields must match, the types of the fields must also match, and the directions\nof the signals must be complementary.  So in general:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each field in struct ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," must have a matching named field in struct ",(0,r.kt)("inlineCode",{parentName:"li"},"B")),(0,r.kt)("li",{parentName:"ul"},"The types of those fields must match"),(0,r.kt)("li",{parentName:"ul"},"The direction of those signals must be opposite"),(0,r.kt)("li",{parentName:"ul"},"Order of the fields is immaterial"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"join")," attribute tells the compiler which interface to mate to this one.")),(0,r.kt)("p",null,"So what can we do with our shiny new interfaces?  Plenty of stuff.  First, lets\nrewrite our FIFO circuit and data producer to use our new interfaces."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct MyFIFO {\n    // The write interface to the FIFO - now only one line!\n    pub write_bus: MyFIFOWriteReceiver,\n}\n\nstruct DataWidget {\n    // The output interface from the DataWidget!\n    pub data_out: MyFIFOWriteSender,\n}\n")),(0,r.kt)("p",null,"That is significantly less verbose!  So what happens to our\n",(0,r.kt)("inlineCode",{parentName:"p"},"impl Logic for Foo"),"?  Well, RustHDL autogenerates 2 methods for each ",(0,r.kt)("inlineCode",{parentName:"p"},"LogicInterface"),".  The first\none is called ",(0,r.kt)("inlineCode",{parentName:"p"},"join"),".  And it, well, joins the interfaces."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl Logic for Foo {\n   #[hdl_gen]\n   fn update(&mut self) {\n      // Excess verbosity eliminated!!\n      MyFIFOWriteSender::join(&mut self.producer.data_out, &mut self.consumer.write_bus);\n   }\n}\n")),(0,r.kt)("p",null,"This is exactly equivalent to our previous 4 lines of hand crafted code, but is now automatically\ngenerated ",(0,r.kt)("em",{parentName:"p"},"and")," synthesizable.  But wait!  There is more.  RustHDL also generates a ",(0,r.kt)("inlineCode",{parentName:"p"},"link"),"\nmethod, which allows you to ",(0,r.kt)("em",{parentName:"p"},"forward")," a bus from one point to another.  If you think in terms\ngendered cables, a ",(0,r.kt)("inlineCode",{parentName:"p"},"join")," is a cable with a Male connector on one end and a Female connector\non the other.  A ",(0,r.kt)("inlineCode",{parentName:"p"},"link")," is a cable that is either Male to Male or Female to Female.  Links\nare useful when you want to forward an interface to an interior component of a circuit, but\nhide that interior component from the outside world.  For example, lets suppose that\n",(0,r.kt)("inlineCode",{parentName:"p"},"DataWidget")," doesn't actually produce the 16-bit samples.  Instead, some other FPGA component\nor circuit generates the 16-bit samples, and ",(0,r.kt)("inlineCode",{parentName:"p"},"DataWidget")," just wraps it along with some\nother control logic.  So in fact, our ",(0,r.kt)("inlineCode",{parentName:"p"},"DataWidget")," has an internal representation that looks\nlike this"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct DataWidget {\n   pub data_out: MyFIFOWriteSender,\n   secret_guy: CryptoGenerator,\n   running: DFF<Bit>,\n}\n\nstruct CryptoGenerator {\n   pub data_out: MyFIFOWriteSender,\n   // secret stuff!\n}\n")),(0,r.kt)("p",null,"In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"DataWidget")," wants to present the outside world that it is a ",(0,r.kt)("inlineCode",{parentName:"p"},"MyFIFOWriteSender"),"\ninterface, and that it can produce 16-bit data values.  But the real work is being done internally\nby the ",(0,r.kt)("inlineCode",{parentName:"p"},"secret_guy"),".  The manual way to do this would be to connect up the signals manually.  Again,\npaying attention to which signal is an input (for ",(0,r.kt)("inlineCode",{parentName:"p"},"DataWidget"),"), and which is an output."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl Logic for DataWidget {\n   #[hdl_gen]\n    fn update(&mut self) {\n       // Yawn...\n       self.data_out.data_to_fifo.next = self.secret_guy.data_out.data_to_fifo.val();\n       self.data_out.write.next = self.secret_guy.data_out.write.val();\n       self.secret_guy.data_out.full.next = self.data_out.full.val();\n       self.secret_guy.data_out.overflow.next = self.data_out.overflow.val();\n    }\n}\n")),(0,r.kt)("p",null,"In these instances, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"link")," method instead.  The syntax is\n",(0,r.kt)("inlineCode",{parentName:"p"},"Interface::link(&mut self.outside, &mut self.inside)"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"outside")," is the\nside of the interface going out of the circuit, and ",(0,r.kt)("inlineCode",{parentName:"p"},"inside")," is the side of the interface\ninside of the circuit.  Hence, our interface can be ",(0,r.kt)("inlineCode",{parentName:"p"},"forwarded")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"linked")," with a single line\nlike so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl Logic for DataWidget {\n   #[hdl_gen]\n    fn update(&mut self) {\n       // Tada!\n       MyFIFOWriteSender::link(&mut self.data_out, &mut self.secret_guy.data_out);\n    }\n}\n")),(0,r.kt)("p",null,"As a parting note, you can make interfaces generic across types.  Here, for example\nis the FIFO interface used in the High Level Synthesis library in RustHDL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Clone, Debug, Default, LogicInterface)]\n#[join = "FIFOWriteResponder"]\npub struct FIFOWriteController<T: Synth> {\n    pub data: Signal<Out, T>,\n    pub write: Signal<Out, Bit>,\n    pub full: Signal<In, Bit>,\n    pub almost_full: Signal<In, Bit>,\n}\n\n#[derive(Clone, Debug, Default, LogicInterface)]\n#[join = "FIFOWriteController"]\npub struct FIFOWriteResponder<T: Synth> {\n    pub data: Signal<In, T>,\n    pub write: Signal<In, Bit>,\n    pub full: Signal<Out, Bit>,\n    pub almost_full: Signal<Out, Bit>,\n}\n')),(0,r.kt)("p",null,"You can then use any synthesizable type for the data bus, and keep the control signals\nas single bits!  Neat, eh? \ud83e\udd91"))}d.isMDXComponent=!0}}]);