"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[972],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),m=a,f=c["".concat(s,".").concat(m)]||c[m]||d[m]||o;return n?r.createElement(f,i(i({ref:t},p),{},{components:n})):r.createElement(f,i({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8449:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const o={},i="Loops and Arrays",l={unversionedId:"guide/rusthdl/loops",id:"guide/rusthdl/loops",title:"Loops and Arrays",description:"A frequently useful feature of hardware is to be able to handle a variable number of",source:"@site/docs/guide/rusthdl/loops.md",sourceDirName:"guide/rusthdl",slug:"/guide/rusthdl/loops",permalink:"/guide/rusthdl/loops",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/rusthdl/loops.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Interfaces",permalink:"/guide/rusthdl/interfaces"},next:{title:"Operations on bits",permalink:"/guide/rusthdl/operators"}},s={},u=[],p={toc:u},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"loops-and-arrays"},"Loops and Arrays"),(0,a.kt)("p",null,"A frequently useful feature of hardware is to be able to handle a variable number of\ninputs or outputs based on some parameter.  Examples might include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A processing stage with a variable number of passes"),(0,a.kt)("li",{parentName:"ul"},"A mux with a variable number of inputs"),(0,a.kt)("li",{parentName:"ul"},"A bank of identical state machines, where the number of banks is variable")),(0,a.kt)("p",null,"In all of these cases, the tool to reach for is an array in RustHDL.  Including an array\nof subcircuits is pretty simple.  You simply use a static sized array (via a ",(0,a.kt)("inlineCode",{parentName:"p"},"const generic"),"\nparameter) or a ",(0,a.kt)("inlineCode",{parentName:"p"},"vec"),".  Here is an example of a circuit that contains a configurable number\nof subcircuits, each of which is an instance of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Pulser")," circuit (a standard RustHDL\nwidget)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n\nstruct PulserSet<const N: usize> {\n    pub outs: Signal<Out, Bits<N>>,\n    pub clock: Signal<In, Clock>,\n    pulsers: [Pulser; N]\n}\n")),(0,a.kt)("p",null,"In this case, as long as the members of the array implement ",(0,a.kt)("inlineCode",{parentName:"p"},"Block")," (i.e., are circuits),\neverything will work as expected, including simulation and synthesis.  "),(0,a.kt)("p",null,"Frequently, though, having an array of subcircuits means you need a way to loop over them\nin order to do something useful with their inputs or outputs.  Loops are were software-centric\nthinking can get you into trouble very quickly.  In hardware, it's best to think of loops\nin terms of unrolling.  A ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop in RustHDL does not actually loop over anything in\nthe hardware.  Rather it is a way of repeating a block of code multiple times with a varying\nparameter."),(0,a.kt)("p",null,"So the ",(0,a.kt)("inlineCode",{parentName:"p"},"impl Logic")," HDL kernel of the ","[PulserSet]"," example above might look something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"impl<const N: usize> Logic for PulserSet<N> {\n    #[hdl_gen]\n    fn update(&mut self) {\n        // Connect all the clocks & enable them all\n        for i in 0..N {\n           self.pulsers[i].clock.next = self.clock.val();\n           self.pulsers[i].enable.next = true.into();\n        }\n        // Connect the outputs...\n        self.outs.next = 0.into();\n        for i in 0..N {\n           self.outs.next = self.outs.val().replace_bit(i, self.pulsers[i].pulse.val());\n        }\n    }\n}\n")),(0,a.kt)("p",null,"Note that we are both reading and writing from ",(0,a.kt)("inlineCode",{parentName:"p"},"self.outs")," in the same kernel, but we write\nfirst, which makes it OK.  Reading first would make this latching behavior, and RustHDL (or\n",(0,a.kt)("inlineCode",{parentName:"p"},"yosys"),") would throw a fit."),(0,a.kt)("p",null,"You can do some basic manipulations with the index (like using ",(0,a.kt)("inlineCode",{parentName:"p"},"3*i+4"),", for example), but\ndon't get carried away.  Those expressions are evaluated by the HDL kernel generator and\nit has a limited vocab."))}d.isMDXComponent=!0}}]);