"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[174],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>y});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var u=n.createContext({}),c=function(e){var t=n.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},l=function(e){var t=c(e.components);return n.createElement(u.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=c(r),d=a,y=m["".concat(u,".").concat(d)]||m[d]||p[d]||o;return r?n.createElement(y,i(i({ref:t},l),{},{components:r})):n.createElement(y,i({ref:t},l))}));function y(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=d;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s[m]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},1634:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const o={},i="Deterministic systems",s={unversionedId:"guide/fpga/deterministic-systems",id:"guide/fpga/deterministic-systems",title:"Deterministic systems",description:"Lets suppose you have to do some incredibly boring and repetitive task,",source:"@site/docs/guide/fpga/deterministic-systems.md",sourceDirName:"guide/fpga",slug:"/guide/fpga/deterministic-systems",permalink:"/guide/fpga/deterministic-systems",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/fpga/deterministic-systems.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Cybersecurity",permalink:"/guide/fpga/cybersecurity"},next:{title:"High Speed I/O",permalink:"/guide/fpga/high-speed-io"}},u={},c=[],l={toc:c},m="wrapper";function p(e){let{components:t,...r}=e;return(0,a.kt)(m,(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"deterministic-systems"},"Deterministic systems"),(0,a.kt)("p",null,"Lets suppose you have to do some incredibly boring and repetitive task,\nlike take the temperature of your Kombucha setup every so often.  Yawn.",(0,a.kt)("br",{parentName:"p"}),"\n","Piece of cake, right?  Fire up you PC, plug in a USB-based thermometer, write\nsome Python code, and go have lunch (and look for your shoes).  Hmmm,\nbut I want to do this constantly - like 24/7.  Oh.  Ok - so an embedded\nsolution.  Like a Raspberry Pi!  Simple enough (and often simple is the best solution)."),(0,a.kt)("p",null,"Let's make it a bit harder.  Instead of reading the temperature every second,\nsuppose we need to measure a ",(0,a.kt)("em",{parentName:"p"},"lot")," more frequently.  Like 10 times a second.\nOr maybe 1000 times a second.  Ok - so regular operating systems don't really like\nthat kind of thing.  They will offer you the ability to run a task periodically, but\nrarely guarantee that nothing will pre-empt your temperature measurement.  How about\na real time operating system (RTOS)?  Sure!  RTOSes can give you deterministic scheduling\nand guarantee that your process will execute when you want.  But most have schedulers\nthat are limited to kilohertz ranges.  As we increase the speed with which we want\nto measure our Kombucha, we find that RTOSes kind of shrug and wave us on."),(0,a.kt)("p",null,"Let's suppose you end up with an embedded solution that with enough wrangling\nand coercion you can get to run at 10KHz - so that you sample the temperature\nfast enough to make your brewmaster happy.  Chances are, you aren't doing a whole\nlot more with your controller at this point.  What if I need a second one measured\nat a different rate?  Um.  Ok - let's say the second one needs to measured at\n20KHz.  Why 20KHz?  Well - because it immediately raises a problem.  On every\nsecond sample, you will be trying to measure 2 temperatures simultaneously.  How\ndo you do that?  In general, a CPU cannot.  CPU cores typically manage a single\nthread of execution at a time.  When you ask them to communicate with thermometer A\nat time T, and then also ask them to communicate with thermometer B at time T,\nthe operating system will pick one of the two and then make the other one wait."))}p.isMDXComponent=!0}}]);