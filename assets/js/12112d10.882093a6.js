"use strict";(self.webpackChunkrust_hdl_org=self.webpackChunkrust_hdl_org||[]).push([[740],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),i=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=i(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),d=i(n),f=a,g=d["".concat(s,".").concat(f)]||d[f]||p[f]||l;return n?r.createElement(g,o(o({ref:t},c),{},{components:n})):r.createElement(g,o({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=f;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=e,u[d]="string"==typeof e?e:a,o[1]=u;for(var i=2;i<l;i++)o[i]=n[i];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},8672:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>u,toc:()=>i});var r=n(7462),a=(n(7294),n(3905));const l={},o="Struct valued signals",u={unversionedId:"guide/rusthdl/struct_valued",id:"guide/rusthdl/struct_valued",title:"Struct valued signals",description:"We have seen how Enums and Interfaces can help make your code more compact and readable.  There",source:"@site/docs/guide/rusthdl/struct_valued.md",sourceDirName:"guide/rusthdl",slug:"/guide/rusthdl/struct_valued",permalink:"/guide/rusthdl/struct_valued",draft:!1,editUrl:"https://github.com/samitbasu/rust-hdl/tree/main/packages/create-docusaurus/templates/shared/docs/guide/rusthdl/struct_valued.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Simulation",permalink:"/guide/rusthdl/simulation"},next:{title:"Synthesizable Subset of Rust",permalink:"/guide/rusthdl/synthesizable"}},s={},i=[],c={toc:i},d="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"struct-valued-signals"},"Struct valued signals"),(0,a.kt)("p",null,"We have seen how Enums and Interfaces can help make your code more compact and readable.  There\nis another abstraction you can use to simplify your code.  Interfaces allow you to group together\nsignals that are logically related into a named bundle (like a bus).  You can also group\ntogether ",(0,a.kt)("inlineCode",{parentName:"p"},"bits")," into a logically related bundle that can be treated as a single entity.",(0,a.kt)("br",{parentName:"p"}),"\n","While this is supported in RustHDL, it's not frequently that useful.  Nonetheless."),(0,a.kt)("p",null,"Suppose you have a set of signals to your circuit that all travel in the same direction,\nbut are different widths.  Any maybe some of the elements are enums.  Something like this"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\nstruct Foo {\n   pub in_red: Signal<In, Bits<5>>,\n   pub in_green: Signal<In, Bits<8>>,\n   pub in_blue: Signal<In, Bits<8>>,\n   pub in_alpha: Signal<In, Bits<6>>,\n}\n")),(0,a.kt)("p",null,"Instead, we can define a struct and annotate it with ","[LogicStruct]",", which makes it into a\ntype that can be used for a signal."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"# use rust_hdl::prelude::*;\n   #[derive(Default, PartialEq, LogicStruct, Copy, Clone, Debug)]\n   struct Color {\n       pub red: Bits<5>,\n       pub green: Bits<8>,\n       pub blue: Bits<8>,\n       pub alpha: Bits<6>,\n   }\n\n   struct Foo {\n       pub in_color: Signal<In, Color>,\n       pub local_color: Signal<Local, Color>,\n       pub out_color: Signal<Out, Color>,\n   }\n\n   impl Logic for Foo {\n       #[hdl_gen]\n       fn update(&mut self) {\n           self.local_color.next = self.in_color.val(); // Copy the struct as a single atom\n                                    // v-- Extract a single field using standard `.field` notation\n           if self.local_color.val().alpha.get_bit(4) {\n               self.local_color.next.red = 16.into(); // Assign to a single field of the struct\n           }\n           self.out_color.next = self.local_color.val();\n       }\n   }\n")),(0,a.kt)("p",null,"From within the HDL kernel, you can access the fields of the struct as you normally would.  You can\nalso assign entire structs to one another, as well as individual fields of a struct.  The generated\nVerilog is messy, and I don't use struct valued signals much.  But if you need to use them they are\nthere."))}p.isMDXComponent=!0}}]);